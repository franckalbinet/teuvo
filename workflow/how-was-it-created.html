<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>How was it created? – teuvo</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-7c6d40aa23c779922b80e0578a9e8972.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
<meta property="og:title" content="How was it created? – teuvo">
<meta property="og:description" content="Self-Organzing Map">
<meta property="og:image" content="https://franckalbinet.github.io/teuvo/workflow/how-was-it-created_files/figure-html/cell-3-output-1.png">
<meta property="og:site_name" content="teuvo">
<meta property="og:image:height" content="404">
<meta property="og:image:width" content="594">
<meta name="twitter:title" content="How was it created? – teuvo">
<meta name="twitter:description" content="Self-Organzing Map">
<meta name="twitter:image" content="https://franckalbinet.github.io/teuvo/workflow/how-was-it-created_files/figure-html/cell-3-output-1.png">
<meta name="twitter:image-height" content="404">
<meta name="twitter:image-width" content="594">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">teuvo</span>
    </a>
  </div>
        <div class="quarto-navbar-tools tools-end">
</div>
          <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../workflow/how-was-it-created.html">How was it created?</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Teuvo</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../workflow/how-was-it-created.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">How was it created?</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Source</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../core.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">core</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#problem-statement" id="toc-problem-statement" class="nav-link active" data-scroll-target="#problem-statement">Problem statement</a></li>
  <li><a href="#table-of-contents" id="toc-table-of-contents" class="nav-link" data-scroll-target="#table-of-contents">Table of Contents</a></li>
  <li><a href="#devising-plan" id="toc-devising-plan" class="nav-link" data-scroll-target="#devising-plan">Devising plan</a></li>
  <li><a href="#carrying-out-the-plan" id="toc-carrying-out-the-plan" class="nav-link" data-scroll-target="#carrying-out-the-plan">Carrying out the plan</a>
  <ul class="collapse">
  <li><a href="#i.-core-som-components" id="toc-i.-core-som-components" class="nav-link" data-scroll-target="#i.-core-som-components">I. CORE SOM COMPONENTS</a>
  <ul class="collapse">
  <li><a href="#i.1-weight-grid" id="toc-i.1-weight-grid" class="nav-link" data-scroll-target="#i.1-weight-grid">I.1 Weight grid</a></li>
  <li><a href="#i.2-distance" id="toc-i.2-distance" class="nav-link" data-scroll-target="#i.2-distance">I.2 Distance</a></li>
  <li><a href="#i.3-bmu-best-matching-unit" id="toc-i.3-bmu-best-matching-unit" class="nav-link" data-scroll-target="#i.3-bmu-best-matching-unit">I.3 BMU (Best Matching Unit)</a></li>
  <li><a href="#i.4-create-neighborhood-function" id="toc-i.4-create-neighborhood-function" class="nav-link" data-scroll-target="#i.4-create-neighborhood-function">I.4 Create neighborhood function</a></li>
  <li><a href="#i.5-implement-weight-update-rule" id="toc-i.5-implement-weight-update-rule" class="nav-link" data-scroll-target="#i.5-implement-weight-update-rule">I.5 Implement weight update rule</a></li>
  <li><a href="#i.6-revised-plan" id="toc-i.6-revised-plan" class="nav-link" data-scroll-target="#i.6-revised-plan">I.6 Revised plan</a></li>
  </ul></li>
  <li><a href="#ii.-extended-training-components" id="toc-ii.-extended-training-components" class="nav-link" data-scroll-target="#ii.-extended-training-components">II. EXTENDED TRAINING COMPONENTS</a>
  <ul class="collapse">
  <li><a href="#ii.1-a-2d-toy-dataset" id="toc-ii.1-a-2d-toy-dataset" class="nav-link" data-scroll-target="#ii.1-a-2d-toy-dataset">II.1 A 2D toy dataset</a></li>
  <li><a href="#ii.2-u-matrix" id="toc-ii.2-u-matrix" class="nav-link" data-scroll-target="#ii.2-u-matrix">II.2 U-Matrix</a></li>
  <li><a href="#ii.3-naive-training-loop" id="toc-ii.3-naive-training-loop" class="nav-link" data-scroll-target="#ii.3-naive-training-loop">II.3 Naive training loop</a></li>
  <li><a href="#ii.4-quantization-error-qe" id="toc-ii.4-quantization-error-qe" class="nav-link" data-scroll-target="#ii.4-quantization-error-qe">II.4 Quantization Error (QE)</a></li>
  <li><a href="#ii.5-topographic-error-te" id="toc-ii.5-topographic-error-te" class="nav-link" data-scroll-target="#ii.5-topographic-error-te">II.5 Topographic Error (TE)</a></li>
  <li><a href="#ii.6-lr-and-σ-schedulers" id="toc-ii.6-lr-and-σ-schedulers" class="nav-link" data-scroll-target="#ii.6-lr-and-σ-schedulers">II.6 LR and σ schedulers</a></li>
  <li><a href="#ii.7-advanced-training-loop-with-schedulers" id="toc-ii.7-advanced-training-loop-with-schedulers" class="nav-link" data-scroll-target="#ii.7-advanced-training-loop-with-schedulers">II.7 Advanced training loop with schedulers</a></li>
  <li><a href="#ii.8-revised-plan" id="toc-ii.8-revised-plan" class="nav-link" data-scroll-target="#ii.8-revised-plan">II.8 Revised plan</a></li>
  </ul></li>
  <li><a href="#iii.-weights-initialization-methods" id="toc-iii.-weights-initialization-methods" class="nav-link" data-scroll-target="#iii.-weights-initialization-methods">III. WEIGHTS INITIALIZATION METHODS</a></li>
  <li><a href="#iii.1-random-initialization" id="toc-iii.1-random-initialization" class="nav-link" data-scroll-target="#iii.1-random-initialization">III.1 Random initialization</a>
  <ul class="collapse">
  <li><a href="#iii.2-pca-initialization" id="toc-iii.2-pca-initialization" class="nav-link" data-scroll-target="#iii.2-pca-initialization">III.2 PCA initialization</a></li>
  </ul></li>
  <li><a href="#iv.-additional-visualizations" id="toc-iv.-additional-visualizations" class="nav-link" data-scroll-target="#iv.-additional-visualizations">IV. ADDITIONAL VISUALIZATIONS</a></li>
  <li><a href="#v.-refactoring" id="toc-v.-refactoring" class="nav-link" data-scroll-target="#v.-refactoring">V. REFACTORING</a>
  <ul class="collapse">
  <li><a href="#v.2-readme.md" id="toc-v.2-readme.md" class="nav-link" data-scroll-target="#v.2-readme.md">V.2 Readme.md</a></li>
  </ul></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/franckalbinet/teuvo/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">How was it created?</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->
<section id="problem-statement" class="level2">
<h2 class="anchored" data-anchor-id="problem-statement">Problem statement</h2>
<p>Reference: <a href="https://www.wikiwand.com/en/articles/Self-organizing_map">Self-Organizing Map (Kohonen)</a></p>
</section>
<section id="table-of-contents" class="level2">
<h2 class="anchored" data-anchor-id="table-of-contents">Table of Contents</h2>
<p><em>NB: Generated a posteriori</em></p>
<p>I. CORE SOM COMPONENTS</p>
<ul>
<li>I.1 Weight Grid Initialization</li>
<li>I.2 Distance Metrics</li>
<li>I.3 BMU (Best Matching Unit)</li>
<li>I.4 Neighborhood Function</li>
<li>I.5 Weight Update Rule</li>
</ul>
<ol start="2" type="I">
<li>EXTENDED TRAINING COMPONENTS</li>
</ol>
<ul>
<li>II.1 A 2D Toy Dataset</li>
<li>II.2 U-Matrix</li>
<li>II.3 Naive Training Loop</li>
<li>II.4 Quantization Error (QE)</li>
<li>II.5 Topographic Error (TE)</li>
<li>II.6 LR and σ Schedulers</li>
<li>II.7 Advanced Training Loop with Schedulers</li>
<li>II.8 Revised Plan</li>
</ul>
<ol start="3" type="I">
<li>WEIGHTS INITIALIZATION METHODS</li>
</ol>
<ul>
<li>III.1 Random Initialization</li>
<li>III.2 PCA Initialization</li>
</ul>
<ol start="4" type="I">
<li>ADDITIONAL VISUALIZATIONS</li>
</ol>
<p>V. REFACTORING</p>
<ul>
<li>V.1 Class Implementation</li>
<li>V.2 README.md</li>
</ul>
<p><strong>AI Prompt</strong></p>
<p>I want to create an Python package implementing a Self Organizing Map. Several Python packages already exist but I would prefer creating it from scratch to be sure to understand every single piece.</p>
<p>The SOM implementation will be flexible and accept different distance metrics, learning rate and gaussian radius schedulers and assess SOM’s quality using relevant metrics.</p>
<p>I want to comply with Polya’s <strong>“How to solve it framework”</strong>.</p>
<p>I want also to make sure it uses <code>numpy</code> vectorization everywhere possible and use <code>fastcore</code>.</p>
<p>Refactoring as <code>class</code> should come at the end.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>AI Response</strong></p>
<p>I’ll help you create a Self-Organizing Map (SOM) implementation from scratch. Let’s follow Polya’s framework step by step.</p>
<ol type="1">
<li>First, let’s understand the problem:
<ul>
<li>Can you tell me your current familiarity with SOMs and what specific aspects you want to focus on?</li>
<li>Are you comfortable with numpy vectorization?</li>
<li>Do you have experience with fastcore?</li>
</ul></li>
</ol>
<p>This will help me tailor the guidance to your needs and ensure we build on your existing knowledge.</p>
<p>Also, before we proceed, could you outline which distance metrics and quality assessment measures you’re particularly interested in implementing? This will help us plan the architecture effectively.</p>
</div>
</div>
<p><strong>AI Prompt</strong></p>
<p>Let me try reformulating the SOM’s approach and tell me if my understanding is correct.</p>
<p>We have a grid of (random - but could be informed by data itself) weights (same dimension of the input).</p>
<p>For each sample of our training set, we want to find the weight most similar to the input (bmu - best matching unit in SOM’s jargon).</p>
<p>Once found we define a neighorhood function that essentially equal to 1 at the grid index of the bmu and decays/vanishes as further away from the bmu, as parametrized by a gaussian function with parameter sigma (to define a notion of “locality”).</p>
<p>Then the objective is to “pull” all weights toward this individual input but proportionaly to this neighborhood function. It means that we take the difference between the given input and the weights, and update the weights according to those differences and the neighborhood function.</p>
<p>A learning rate parameter also allow to specifify how quickly we want to update the weights for each sample.</p>
<p>What do you think? Did I capture the key concepts?</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>AI Response</strong></p>
<p>Yes, that’s an excellent and accurate description of the SOM algorithm! Let me highlight the key components you’ve identified:</p>
<ol type="1">
<li>Grid of weights (prototype vectors)
<ul>
<li>Initialize randomly (or with PCA/other informed methods)</li>
<li>Same dimensionality as input data</li>
</ul></li>
<li>Best Matching Unit (BMU)
<ul>
<li>For each input, find closest weight vector</li>
<li>Requires distance metric (commonly Euclidean)</li>
</ul></li>
<li>Neighborhood function
<ul>
<li>Gaussian decay from BMU location</li>
<li>Controlled by sigma parameter (radius)</li>
<li>Defines “influence zone” on grid</li>
</ul></li>
<li>Weight update rule
<ul>
<li>Pull weights towards input</li>
<li>Strength determined by:
<ul>
<li>Learning rate (overall step size)</li>
<li>Neighborhood function (locality-based influence)</li>
</ul></li>
</ul></li>
</ol>
<p>Would you like to start breaking this down into smaller implementation steps? We could begin by focusing on one of these components. Which part would you like to tackle first?</p>
</div>
</div>
</section>
<section id="devising-plan" class="level1">
<h1>Devising plan</h1>
<p><strong>AI Prompt</strong></p>
<p>Ok let’s devise a plan that I can use to further monitor my progress along my implementation.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>AI Response</strong></p>
<p>Following Polya’s framework, let’s create a structured plan. Here’s a suggested breakdown - please let me know if you’d like to modify any part:</p>
<ol type="1">
<li>Core SOM Components
<ul>
<li>Initialize weight grid</li>
<li>Implement distance metrics (Euclidean first, others later)</li>
<li>Find BMU function</li>
<li>Create neighborhood function</li>
<li>Implement weight update rule</li>
</ul></li>
<li>Training Loop
<ul>
<li>Single sample update</li>
<li>Full epoch processing</li>
<li>Learning rate scheduling</li>
<li>Radius (sigma) scheduling</li>
</ul></li>
<li>Quality Metrics
<ul>
<li>Quantization error</li>
<li>Topographic error</li>
<li>Other quality measures</li>
</ul></li>
<li>Utilities &amp; Visualization
<ul>
<li>Grid visualization</li>
<li>U-Matrix</li>
<li>Component planes</li>
</ul></li>
<li>Refactoring
<ul>
<li>Create class structure</li>
<li>Add flexibility for different metrics/schedulers</li>
<li>Documentation</li>
</ul></li>
</ol>
<p>Would you like to refine this plan? We can discuss what specific functionality you want in each component before starting the implementation.</p>
</div>
</div>
<p><strong>AI Prompt</strong></p>
<p>It sounds perfect! Let’s carry out the plan.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>AI Response</strong></p>
<p>Great! Let’s start with the first component: initializing the weight grid.</p>
<p>Before we write any code, we need to decide: 1. What parameters will we need for initialization? - Grid dimensions (e.g., n_rows, n_cols) - Input data dimension - Initialization method (random, PCA-based, etc.)</p>
<p>Would you like to start implementing the weight grid initialization? What initialization method would you prefer to begin with?</p>
<p>Let me know your preferences, and we can discuss how to make it efficient using numpy vectorization.</p>
</div>
</div>
</section>
<section id="carrying-out-the-plan" class="level1">
<h1>Carrying out the plan</h1>
<section id="i.-core-som-components" class="level2">
<h2 class="anchored" data-anchor-id="i.-core-som-components">I. CORE SOM COMPONENTS</h2>
<section id="i.1-weight-grid" class="level3">
<h3 class="anchored" data-anchor-id="i.1-weight-grid">I.1 Weight grid</h3>
<div id="cell-16" class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>grid_sz <span class="op">=</span> (<span class="dv">3</span>,<span class="dv">3</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>ws <span class="op">=</span> np.random.randn(<span class="op">*</span>grid_sz)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>ws.shape, ws</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>ws.shape, ws</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>((3, 3),
 array([[-1.361616  , -0.47049376, -0.95493151],
        [ 1.41949963, -0.01988135, -1.88250715],
        [-0.41864399, -1.87207718, -0.51610482]]))</code></pre>
</div>
</div>
<div id="cell-17" class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">3</span>, <span class="dv">2</span>))  <span class="co"># Compact figure size</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>plt.rcParams.update({<span class="st">'font.size'</span>: <span class="dv">6</span>})  <span class="co"># Base font size</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Create meshgrid for plotting</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>x, y <span class="op">=</span> np.meshgrid(<span class="bu">range</span>(grid_sz[<span class="dv">0</span>]), <span class="bu">range</span>(grid_sz[<span class="dv">1</span>]))</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>plt.scatter(x, y, c<span class="op">=</span>ws, s<span class="op">=</span><span class="dv">100</span>, cmap<span class="op">=</span><span class="st">'viridis'</span>)  </span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>plt.colorbar(label<span class="op">=</span><span class="st">'Weight values'</span>)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'2D SOM Grid Initial Weights'</span>, fontsize<span class="op">=</span><span class="dv">6</span>)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'X coordinate'</span>, fontsize<span class="op">=</span><span class="dv">6</span>)</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Y coordinate'</span>, fontsize<span class="op">=</span><span class="dv">6</span>)</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>plt.xticks(fontsize<span class="op">=</span><span class="dv">6</span>)</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>plt.yticks(fontsize<span class="op">=</span><span class="dv">6</span>)</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="how-was-it-created_files/figure-html/cell-3-output-1.png" width="297" height="202" class="figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="i.2-distance" class="level3">
<h3 class="anchored" data-anchor-id="i.2-distance">I.2 Distance</h3>
<div id="cell-19" class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>ws <span class="op">=</span> np.random.randn(<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">200</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>ws.shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>(3, 3, 200)</code></pre>
</div>
</div>
<div id="cell-20" class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> np.random.randn(<span class="dv">100</span>,<span class="dv">200</span>)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>X.shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>(100, 200)</code></pre>
</div>
</div>
<div id="cell-21" class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>X[<span class="dv">0</span>].shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>(200,)</code></pre>
</div>
</div>
<p><strong>AI Prompt</strong></p>
<p>Each node of the grid (here 3x3) has a weight of 200 dimensions in our toy example. How to take the euclidean distance between each weight and a 200-dimensional input?</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>AI Response</strong></p>
<p>Let’s think about this vectorized approach:</p>
<ol type="1">
<li>For Euclidean distance, we need √(Σ(x-w)²) between:
<ul>
<li>One input vector (1, 200)</li>
<li>All weight vectors (3, 3, 200)</li>
</ul></li>
</ol>
<p>We have two main vectorized approaches we could use: 1. Using numpy broadcasting and np.sum 2. Using scipy’s cdist (which handles this specific case)</p>
<p>Would you like to try implementing one of these approaches? I can guide you through the numpy broadcasting solution first if you’d like, or we can discuss the trade-offs between the two approaches.</p>
<p>Which would you prefer to explore first?</p>
</div>
</div>
<p><code>Numpy</code> will broadcast the 1-dimensioal input vector of shape <code>(200,)</code> to <code>(3,3,200)</code> to align it to the weights shape. We want the distance between each unit (200-dimensional in our toy example) and the given input. There are two ways to do so. Either using native <code>numpy</code> or …</p>
<div id="cell-25" class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Element-wise distance between each `(200,)` node/weights and the input.</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>(X[<span class="dv">0</span>]<span class="op">-</span>ws).shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>(3, 3, 200)</code></pre>
</div>
</div>
<div id="cell-26" class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Now we take the root square of the square distance element-wise and take their sum along the last dimension (200)</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>np.sqrt(np.<span class="bu">sum</span>((X[<span class="dv">0</span>]<span class="op">-</span>ws)<span class="op">**</span><span class="dv">2</span>, axis<span class="op">=-</span><span class="dv">1</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>array([[17.91644487, 19.40803926, 18.10014622],
       [18.92468523, 19.64872772, 21.76170238],
       [21.98737528, 20.59933278, 19.29730677]])</code></pre>
</div>
</div>
<div id="cell-27" class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># We can do it also using numpy dedicated method</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>np.linalg.norm(ws<span class="op">-</span>X[<span class="dv">0</span>], axis<span class="op">=-</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>array([[17.91644487, 19.40803926, 18.10014622],
       [18.92468523, 19.64872772, 21.76170238],
       [21.98737528, 20.59933278, 19.29730677]])</code></pre>
</div>
</div>
<div id="cell-28" class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co"># This is to be injected into the final class for further flexibility</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>dist_fn <span class="op">=</span> <span class="kw">lambda</span> x, ws: np.linalg.norm(ws<span class="op">-</span>x, axis<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>dist_fn(X[<span class="dv">0</span>], ws)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>array([[17.91644487, 19.40803926, 18.10014622],
       [18.92468523, 19.64872772, 21.76170238],
       [21.98737528, 20.59933278, 19.29730677]])</code></pre>
</div>
</div>
</section>
<section id="i.3-bmu-best-matching-unit" class="level3">
<h3 class="anchored" data-anchor-id="i.3-bmu-best-matching-unit">I.3 BMU (Best Matching Unit)</h3>
<p><strong>AI Prompt</strong></p>
<p>I’d like to find the closest unit/node from a given input and want to return its index.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>AI Response</strong></p>
<p>To find the BMU index, we need to: 1. Get the distances (which we already calculated) 2. Find the index of the minimum distance in our 2D grid</p>
<p>We can use <code>np.argmin()</code>, but since we have a 2D grid, we’ll need to consider how to handle the indices. Would you like to try implementing this yourself, or would you like me to suggest an approach?</p>
<p>A key consideration is whether you want: - A flat index (single number) - Grid coordinates (row, col)</p>
<p>Which format would be more useful for your implementation?</p>
</div>
</div>
<p><strong>AI Prompt</strong></p>
<p>I want to find the grid coordinates but <code>np.argmin()</code> seems to work only for flatten arrays.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>AI Response</strong></p>
<p>Ah yes! For 2D coordinates, we can use <code>np.unravel_index()</code> together with <code>np.argmin()</code>. This combination will:</p>
<ol type="1">
<li><code>np.argmin()</code> finds the index in the flattened array</li>
<li><code>np.unravel_index()</code> converts this flat index back to grid coordinates</li>
</ol>
<p>Would you like to try implementing this yourself using these functions? I can provide more details about how <code>np.unravel_index()</code> works if needed.</p>
</div>
</div>
<div id="cell-34" class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">1</span>)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>ws <span class="op">=</span> np.random.randn(<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">1</span>)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.array(<span class="fl">0.5</span>)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> dist_fn(X[<span class="dv">0</span>], ws)</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(x, <span class="st">'</span><span class="ch">\n</span><span class="st">'</span>, d)</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>np.argmin(d)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>0.5 
 [[27.38521073 16.09891829]
 [15.54144978 20.16819721]]</code></pre>
</div>
<div class="cell-output cell-output-display">
<pre><code>2</code></pre>
</div>
</div>
<div id="cell-35" class="cell">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>np.unravel_index(<span class="dv">2</span>,shape<span class="op">=</span>ws.shape[:<span class="dv">2</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>(1, 0)</code></pre>
</div>
</div>
<p>So, finding the grid index of the smallest distance is as simple as taking the <code>np.argmin</code> (internally flattening the array) and then using <code>np.unravel_index</code> with grid shape specified:</p>
<div id="cell-37" class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bmu_coords(dists, sz):</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.unravel_index(np.argmin(dists), sz)</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>bmu_coords(dist_fn(X[<span class="dv">0</span>], ws), ws.shape[:<span class="dv">2</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>(1, 0)</code></pre>
</div>
</div>
</section>
<section id="i.4-create-neighborhood-function" class="level3">
<h3 class="anchored" data-anchor-id="i.4-create-neighborhood-function">I.4 Create neighborhood function</h3>
<p><strong>AI Prompt</strong></p>
<p>Let me try to recap and reformulate the role of the neighborhood function with my own words. The weights update will be carried out according to the following logic: 1. we first get the distance between a given input and all units/nodes 2. the closest unit is called the bmu 3. Each unit will be then updated as a function of: - its distance from the given input - but also of its “decayed” distance of its grid index from the bmu - by “decayed” we mean that using a gaussian function parametrized by a “radius of influence” or a “degree of locality”, we update the units close from the bmu more than the distant one.</p>
<p>Hence the neighborhood function, should return for a given node a coefficient that will be used to further weigh the weights update. Last, it is important to note that this update will be further parametrized by a learning rate <code>lr</code>.</p>
<p>Is my thinking correct?</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>AI Response</strong></p>
<p>Yes, your understanding is excellent! You’ve captured all the key aspects of the neighborhood function and its role in weight updates. Let me confirm each point:</p>
<ol type="1">
<li>✓ Calculate distances &amp; find BMU</li>
<li>✓ For each unit, weight update depends on:
<ul>
<li>Distance from input (the error term)</li>
<li>Distance from BMU on the grid (neighborhood influence)</li>
<li>Gaussian decay based on grid distance (controlled by radius σ)</li>
</ul></li>
<li>✓ Final update magnitude determined by:
<ul>
<li>Neighborhood coefficient (from gaussian)</li>
<li>Learning rate (lr)</li>
</ul></li>
</ol>
<p>Would you like to start implementing the neighborhood function? We’ll need to: 1. Calculate grid distances from BMU to all nodes 2. Apply gaussian decay to these distances</p>
<p>Which part would you like to tackle first?</p>
</div>
</div>
<div id="cell-41" class="cell">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>ws <span class="op">=</span> np.random.randn(<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">1</span>)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>bmu_idx <span class="op">=</span> (<span class="dv">2</span>,<span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-42" class="cell">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 1 row, 3 cols</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> np.array([</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    ])</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>a.shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>(1, 4)</code></pre>
</div>
</div>
<div id="cell-43" class="cell">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 3 rows, 1 col</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> np.array([</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">10</span>],</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">20</span>],</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">30</span>]</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>    ])</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>b.shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>(3, 1)</code></pre>
</div>
</div>
<div id="cell-44" class="cell">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co"># (3, 1) + (1, 4) -&gt; (3,4)</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="co"># or (1, 4) + (3, 1) -&gt; (3, 4)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-45" class="cell">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">+</span> b</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>array([[11, 12, 13, 14],
       [21, 22, 23, 24],
       [31, 32, 33, 34]])</code></pre>
</div>
</div>
<div id="cell-46" class="cell">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>b <span class="op">+</span> a</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>array([[11, 12, 13, 14],
       [21, 22, 23, 24],
       [31, 32, 33, 34]])</code></pre>
</div>
</div>
<div id="cell-47" class="cell">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>bmu_idx</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>(2, 2)</code></pre>
</div>
</div>
<p><strong>AI Prompt</strong></p>
<p>From the <code>(3,4)</code> shape I’d like to create two numpy arrays: one of shape (1,4) with the following values [0,1,2,3] (the rows idx) and one of shape (3,1) with the following values [0,1,2]. From those arrays, I then want to calculate the delta x and delta y from the bmu coordinates to eventually get a neighborhood function then I’d further weigh by a gaussian kernel. Can you guide me?</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>AI Response</strong></p>
<p>I’ll help you step by step:</p>
<ol type="1">
<li>First, let’s create those two arrays using <code>np.arange()</code>:</li>
</ol>
<div class="sourceCode" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>x_coords <span class="op">=</span> np.arange(<span class="dv">4</span>).reshape(<span class="dv">1</span>, <span class="dv">4</span>)  <span class="co"># [0,1,2,3] shape (1,4)</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>y_coords <span class="op">=</span> np.arange(<span class="dv">3</span>).reshape(<span class="dv">3</span>, <span class="dv">1</span>)  <span class="co"># [0,1,2] shape (3,1)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Would you like to try this first and then we can move on to calculating the deltas from the BMU coordinates?</p>
<p>The next step would be subtracting the BMU’s x and y coordinates from these arrays. Would you like to try that yourself, or would you like more guidance?</p>
</div>
</div>
<p><strong>AI Prompt</strong></p>
<p>Isn’t there a more straightforward to get those x and y coords directly from the shape (3,4) using a dedicated numpy method?</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>AI Response</strong></p>
<p>Ah yes! You can use <code>np.meshgrid()</code> to directly generate coordinate arrays from the shape. This function is specifically designed for creating coordinate matrices. Would you like to explore how to use <code>np.meshgrid()</code> for this purpose?</p>
<p>Let me know if you want to try it yourself first, or if you’d like me to show you how it works with your (3,4) shape example.</p>
</div>
</div>
<p><strong>AI Prompt</strong></p>
<p>I’ve heard about this method: <code>np.ogrid[0:grid_sz[0], 0:grid_sz[1]]</code> Don’t you think it would be more convenient?</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>AI Response</strong></p>
<p>Yes, absolutely! <code>np.ogrid</code> is a more concise and elegant solution for this case. It creates an “open mesh” which is exactly what we need - two arrays suitable for broadcasting, without actually storing the full mesh in memory.</p>
<p>Would you like to try using <code>np.ogrid</code> to: 1. Create the coordinate arrays 2. Calculate the deltas from the BMU position</p>
<p>Which step would you like to tackle first?</p>
</div>
</div>
<div id="cell-54" class="cell">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>x_coords, y_coords <span class="op">=</span> np.ogrid[<span class="dv">0</span>:ws.shape[<span class="dv">0</span>], <span class="dv">0</span>:ws.shape[<span class="dv">1</span>]]</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>x_coords, y_coords</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>(array([[0],
        [1],
        [2]]),
 array([[0, 1, 2, 3]]))</code></pre>
</div>
</div>
<div id="cell-55" class="cell">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>bmu_idx, bmu_idx[<span class="dv">0</span>] <span class="op">-</span> x_coords</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>((2, 2),
 array([[2],
        [1],
        [0]]))</code></pre>
</div>
</div>
<div id="cell-56" class="cell">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>bmu_idx[<span class="dv">1</span>] <span class="op">-</span> y_coords</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>array([[ 2,  1,  0, -1]])</code></pre>
</div>
</div>
<div id="cell-57" class="cell">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>(bmu_idx[<span class="dv">0</span>] <span class="op">-</span> x_coords)<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> (bmu_idx[<span class="dv">1</span>] <span class="op">-</span> y_coords)<span class="op">**</span><span class="dv">2</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>array([[8, 5, 4, 5],
       [5, 2, 1, 2],
       [4, 1, 0, 1]])</code></pre>
</div>
</div>
<div id="cell-58" class="cell">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> grid_dist2(bmu_idx, grid_sz):</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>    rows_idx, cols_idx <span class="op">=</span> np.ogrid[<span class="dv">0</span>:grid_sz[<span class="dv">0</span>], <span class="dv">0</span>:grid_sz[<span class="dv">1</span>]]</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (bmu_idx[<span class="dv">0</span>] <span class="op">-</span> rows_idx)<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> (bmu_idx[<span class="dv">1</span>] <span class="op">-</span> cols_idx)<span class="op">**</span><span class="dv">2</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>grid_dist2(bmu_idx, ws.shape[:<span class="dv">2</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>array([[8, 5, 4, 5],
       [5, 2, 1, 2],
       [4, 1, 0, 1]])</code></pre>
</div>
</div>
<p><strong>AI Prompt</strong></p>
<p>I think that now suffices to pass this array to a Gaussian function to create our neighborhood function, don’t you think?</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>AI Response</strong></p>
<p>Yes, exactly! We can create a Gaussian decay function using <code>np.exp(-dist²/(2σ²))</code>, where: - dist² is what we just calculated - σ (sigma) is our radius parameter that controls the spread of the neighborhood</p>
<p>Would you like to try implementing this Gaussian function? We’ll need to: 1. Take our squared distances 2. Apply the Gaussian formula with a sigma parameter</p>
<p>Would you like to try this yourself, or would you like some guidance on the implementation?</p>
</div>
</div>
<div id="cell-61" class="cell">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>gaussian_fn <span class="op">=</span> <span class="kw">lambda</span> dists, sigma: np.exp(<span class="op">-</span>dists<span class="op">/</span>(<span class="dv">2</span><span class="op">*</span>sigma<span class="op">**</span><span class="dv">2</span>))</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>gaussian_fn(grid_dist2(bmu_idx, ws.shape[:<span class="dv">2</span>]), <span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>array([[0.01831564, 0.082085  , 0.13533528, 0.082085  ],
       [0.082085  , 0.36787944, 0.60653066, 0.36787944],
       [0.13533528, 0.60653066, 1.        , 0.60653066]])</code></pre>
</div>
</div>
<div id="cell-62" class="cell">
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> functools <span class="im">import</span> partial</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> neighborhood_fn(dists, kernel_fn):</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> kernel_fn(dists)</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>dists <span class="op">=</span> grid_dist2(bmu_idx, ws.shape[:<span class="dv">2</span>])</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>kernel_fn <span class="op">=</span> partial(gaussian_fn, sigma<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a>neighborhood_fn(dists, kernel_fn)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>array([[0.01831564, 0.082085  , 0.13533528, 0.082085  ],
       [0.082085  , 0.36787944, 0.60653066, 0.36787944],
       [0.13533528, 0.60653066, 1.        , 0.60653066]])</code></pre>
</div>
</div>
</section>
<section id="i.5-implement-weight-update-rule" class="level3">
<h3 class="anchored" data-anchor-id="i.5-implement-weight-update-rule">I.5 Implement weight update rule</h3>
<p><strong>AI Prompt</strong></p>
<p>Let me reformulate the weight update rule. Given an input, the SOM weights/nodes/units will be updated as follows: 1. compute the distance between the input and all weights/nodes/units, <code>d</code> 2. compute the distance from the bmu position from all other grids/weights position <code>d_grid`` 3.</code>w_new = w + lr<em>d</em>neighborhood_fn(d_grid) where lr is the learning rate</p>
<p>In summary at every iteration (new sample), we pull all weights and their surroundings (as defined by the neighborhood function) toward the input (the bmu weights being the most affected).</p>
<p>Am I right?</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>AI Response</strong></p>
<p>Yes, your understanding is perfect! Let me break down your correct formulation:</p>
<p>For each input sample: 1. ✓ Calculate distances between input and all weights 2. ✓ Find BMU (closest weight) 3. ✓ Calculate grid distances from BMU position 4. ✓ Apply neighborhood function to grid distances 5. ✓ Update weights using the formula: <code>w_new = w + lr * (input - w) * neighborhood_fn(d_grid)</code></p>
<p>One small clarification to your formula: the <code>d</code> term should be <code>(input - w)</code>, representing the direction and magnitude of the update.</p>
<p>Would you like to try implementing this update rule? We can break it down into steps if you’d like.</p>
</div>
</div>
<p>Let’s do it step-by-step while checking shapes “compatibility” for numpy broadcasting.</p>
<div id="cell-67" class="cell">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>ws <span class="op">=</span> np.random.randn(<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">3</span>)</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.array([<span class="fl">0.5</span>, <span class="fl">0.1</span>, <span class="fl">0.2</span>])</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>(x<span class="op">-</span>ws).shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>(2, 2, 3)</code></pre>
</div>
</div>
<div id="cell-68" class="cell">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Define kernel function with wanted parameter</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>kernel_fn <span class="op">=</span> partial(gaussian_fn, sigma<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Get bmu position</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>bmu_idx <span class="op">=</span> bmu_coords(dist_fn(x, ws), ws.shape[:<span class="dv">2</span>])</span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute neighborhood weights for each unit</span></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>nbh <span class="op">=</span> neighborhood_fn(grid_dist2(bmu_idx, ws.shape[:<span class="dv">2</span>]), kernel_fn)</span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>nbh.shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>(2, 2)</code></pre>
</div>
</div>
<p>The neighborhood will weigh eacg node’s update give its distance from the bmu and provided kernel functions. So we want an element-wised multiplication between this <code>2x2</code>array and the first two dimensions of the (x-ws) differences. Hence to be able to use numpy broadasting we have to add an additional trailing dimension to the neighborhood.</p>
<div id="cell-70" class="cell">
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>nbh[..., np.newaxis].shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>(2, 2, 1)</code></pre>
</div>
</div>
<div id="cell-71" class="cell">
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>(nbh[..., np.newaxis] <span class="op">*</span> (x<span class="op">-</span>ws)).shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>(2, 2, 3)</code></pre>
</div>
</div>
<p>We now have all components required to define the update function.</p>
<div id="cell-73" class="cell">
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>lr <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>ws <span class="op">=</span> np.random.randn(<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">3</span>)</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.array(<span class="fl">0.5</span>)</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> dist_fn(x, ws)</span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a>bmu_idx <span class="op">=</span> bmu_coords(d, ws.shape[:<span class="dv">2</span>])</span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a>d_grid <span class="op">=</span> grid_dist2(bmu_idx, ws.shape[:<span class="dv">2</span>])</span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a>kernel_fn <span class="op">=</span> partial(gaussian_fn, sigma<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a>nbh <span class="op">=</span> neighborhood_fn(grid_dist2(bmu_idx, ws.shape[:<span class="dv">2</span>]), kernel_fn)</span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true" tabindex="-1"></a>ws <span class="op">+</span> lr <span class="op">*</span> (nbh[..., np.newaxis] <span class="op">*</span> (x<span class="op">-</span>ws))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>array([[[ 0.01460216,  0.51918831, -0.25327326],
        [ 0.14715498,  0.03288394, -0.02929718]],

       [[ 0.03915056,  0.2982822 , -0.13636204],
        [ 0.5       ,  0.5       ,  0.5       ]]])</code></pre>
</div>
</div>
<div id="cell-74" class="cell">
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> update(x, ws, dist_fn, kernel_fn, lr<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>    bmu_idx <span class="op">=</span> bmu_coords(dist_fn(x, ws), ws.shape[:<span class="dv">2</span>])</span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>    d_grid <span class="op">=</span> grid_dist2(bmu_idx, ws.shape[:<span class="dv">2</span>])</span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>    nbh <span class="op">=</span> neighborhood_fn(grid_dist2(bmu_idx, ws.shape[:<span class="dv">2</span>]), kernel_fn)</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ws <span class="op">+</span> lr <span class="op">*</span> nbh[..., np.newaxis] <span class="op">*</span> (x<span class="op">-</span>ws)</span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>ws <span class="op">=</span> np.random.randn(<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">3</span>)</span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.array([<span class="fl">0.5</span>, <span class="fl">0.1</span>, <span class="fl">0.2</span>])</span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a>kernel_fn <span class="op">=</span> partial(gaussian_fn, sigma<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a>update(x, ws, dist_fn, kernel_fn, lr<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>array([[[ 0.06267652, -0.52430057, -0.39871823],
        [ 0.96919433,  0.08064436, -0.12933212]],

       [[ 0.37838472,  0.88703907,  0.168585  ],
        [ 0.5       ,  0.1       ,  0.2       ]]])</code></pre>
</div>
</div>
<div id="cell-75" class="cell">
<div class="sourceCode cell-code" id="cb64"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>ws <span class="op">=</span> np.array([</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>    [[<span class="dv">1</span>], [<span class="dv">2</span>]], </span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>    [[<span class="dv">3</span>], [<span class="dv">4</span>]</span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>    ]])</span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>np.squeeze(ws) <span class="co"># squeeze the trailing dim for clearer printing</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>array([[1, 2],
       [3, 4]])</code></pre>
</div>
</div>
<div id="cell-76" class="cell">
<div class="sourceCode cell-code" id="cb66"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.array(<span class="fl">3.8</span>)</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>np.squeeze(update(x, ws, dist_fn, kernel_fn, lr<span class="op">=</span><span class="dv">1</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>array([[2.03006244, 3.09175519],
       [3.48522453, 3.8       ]])</code></pre>
</div>
</div>
<p>Ok, we observe that the SOM’s nodes are pulled toward the bmu accordingly. We have all core SOM compoenents, we can implement now the training loop.</p>
</section>
<section id="i.6-revised-plan" class="level3">
<h3 class="anchored" data-anchor-id="i.6-revised-plan">I.6 Revised plan</h3>
<p><strong>AI Prompt</strong></p>
<p>I think that should be pretty straightforward to implement. We know how to update the SOM/weights for every single data point. It suffices to iterate over the training set multiple times (epochs) until we think this is enough right?</p>
<p>Obviously it raises a couple of questions. First usually, the learning rate and for instance the gaussian kernel sigma are decayed during training. Second, after each epoch (one pass over the train set), we’d like to log some metrics (Quantization error and Topographic error). Also, I think that would be very useful if we could visualize how the SOM improves as we add new features like scheduled learning rate and gaussian kernel sigma. Hence, I’d like to implement a U-Matrix visualization in priority. So I think we have to slightly revised the initial plan (shown below) to take into account both decay, metrics and U-matrix now as it is interleaved with the training loop. Ideally, we should implement second the training loop but implement in this main step also U-Matrix visualization, … so that we can see how the training loop, training loop + scheduler affect the training visually.</p>
<p>Initial plan: Following Polya’s framework, let’s create a structured plan. Here’s a suggested breakdown - please let me know if you’d like to modify any part:</p>
<ol type="1">
<li>Core SOM Components
<ul>
<li>Initialize weight grid (DONE)</li>
<li>Implement distance metrics (Euclidean first, others later) (DONE)</li>
<li>Find BMU function (DONE)</li>
<li>Create neighborhood function (DONE)</li>
<li>Implement weight update rule (DONE)</li>
</ul></li>
<li>Training Loop
<ul>
<li>Single sample update (DONE)</li>
<li>Full epoch processing</li>
<li>Learning rate scheduling</li>
<li>Radius (sigma) scheduling</li>
</ul></li>
<li>Quality Metrics
<ul>
<li>Quantization error</li>
<li>Topographic error</li>
<li>Other quality measures</li>
</ul></li>
<li>Utilities &amp; Visualization
<ul>
<li>Grid visualization</li>
<li>U-Matrix</li>
<li>Component planes</li>
</ul></li>
<li>Refactoring
<ul>
<li>Create class structure</li>
<li>Add flexibility for different metrics/schedulers</li>
<li>Documentation</li>
</ul></li>
</ol>
<p>Please adjust the plan accordingly.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>AI Response</strong></p>
<p>You make excellent points! Yes, we should revise the plan to better integrate visualization and metrics with the training loop, since they’re crucial for understanding how the SOM evolves. Here’s a suggested revision:</p>
<ol type="1">
<li>Core SOM Components (DONE)
<ul>
<li>✓ Initialize weight grid</li>
<li>✓ Distance metrics</li>
<li>✓ BMU function</li>
<li>✓ Neighborhood function</li>
<li>✓ Weight update rule</li>
</ul></li>
<li>Extended Training Components
<ul>
<li>Training loop structure</li>
<li>U-Matrix visualization (moved up from 4)</li>
<li>Basic quality metrics (moved up from 3)</li>
<li>Learning rate scheduler</li>
<li>Radius scheduler</li>
<li>Training progress visualization</li>
</ul></li>
<li>Additional Quality Metrics
<ul>
<li>Quantization error</li>
<li>Topographic error</li>
<li>Custom metrics interface</li>
</ul></li>
<li>Additional Visualizations
<ul>
<li>Component planes</li>
<li>Custom visualization options</li>
</ul></li>
<li>Refactoring
<ul>
<li>Class structure</li>
<li>Flexible interfaces</li>
<li>Documentation</li>
</ul></li>
</ol>
<p>Would you like to start with implementing the training loop along with U-Matrix visualization so you can see the SOM’s evolution during training?</p>
</div>
</div>
</section>
</section>
<section id="ii.-extended-training-components" class="level2">
<h2 class="anchored" data-anchor-id="ii.-extended-training-components">II. EXTENDED TRAINING COMPONENTS</h2>
<p>Let’s first implementing a training (fit) loop to see where and how scheduling should take place.</p>
<section id="ii.1-a-2d-toy-dataset" class="level3">
<h3 class="anchored" data-anchor-id="ii.1-a-2d-toy-dataset">II.1 A 2D toy dataset</h3>
<div id="cell-84" class="cell">
<div class="sourceCode cell-code" id="cb68"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span>pip3 install scikit<span class="op">-</span>learn</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Defaulting to user installation because normal site-packages is not writeable
Requirement already satisfied: scikit-learn in ./.local/lib/python3.11/site-packages (1.6.0)
Requirement already satisfied: numpy&gt;=1.19.5 in /usr/local/lib/python3.11/site-packages (from scikit-learn) (1.26.3)
Requirement already satisfied: scipy&gt;=1.6.0 in /usr/local/lib/python3.11/site-packages (from scikit-learn) (1.14.1)
Requirement already satisfied: joblib&gt;=1.2.0 in ./.local/lib/python3.11/site-packages (from scikit-learn) (1.4.2)
Requirement already satisfied: threadpoolctl&gt;=3.1.0 in ./.local/lib/python3.11/site-packages (from scikit-learn) (3.5.0)

[notice] A new release of pip is available: 24.0 -&gt; 24.3.1
[notice] To update, run: pip install --upgrade pip</code></pre>
</div>
</div>
<div id="cell-85" class="cell">
<div class="sourceCode cell-code" id="cb70"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.datasets <span class="im">import</span> make_blobs, make_moons, make_swiss_roll</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>X, y <span class="op">=</span> make_blobs(n_samples<span class="op">=</span><span class="dv">1_000</span>, centers<span class="op">=</span><span class="dv">3</span>, cluster_std<span class="op">=</span><span class="fl">0.5</span>, random_state<span class="op">=</span><span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-86" class="cell">
<div class="sourceCode cell-code" id="cb71"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">2</span>,<span class="dv">2</span>))</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>plt.scatter(X[:, <span class="dv">0</span>], X[:, <span class="dv">1</span>], c<span class="op">=</span>y, cmap<span class="op">=</span><span class="st">'viridis'</span>, s<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Three normally-distributed clusters"</span>)</span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="how-was-it-created_files/figure-html/cell-38-output-1.png" width="200" height="208" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="cell-87" class="cell">
<div class="sourceCode cell-code" id="cb72"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>X.shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>(1000, 2)</code></pre>
</div>
</div>
<div id="cell-88" class="cell">
<div class="sourceCode cell-code" id="cb74"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a>n_nodes <span class="op">=</span> <span class="kw">lambda</span> n_samples: <span class="bu">int</span>(np.sqrt(<span class="dv">5</span><span class="op">*</span>np.sqrt(n_samples)))</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>n_nodes(<span class="dv">200</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>8</code></pre>
</div>
</div>
<div id="cell-89" class="cell">
<div class="sourceCode cell-code" id="cb76"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a>n_samples <span class="op">=</span> <span class="bu">len</span>(X)</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>grid_sz <span class="op">=</span> (n_nodes(n_samples),n_nodes(n_samples))</span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a>ws <span class="op">=</span> np.random.randn(<span class="op">*</span>grid_sz, X.shape[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a>ws.shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>(12, 12, 2)</code></pre>
</div>
</div>
</section>
<section id="ii.2-u-matrix" class="level3">
<h3 class="anchored" data-anchor-id="ii.2-u-matrix">II.2 U-Matrix</h3>
<p><strong>AI Prompt</strong></p>
<p>I’d like to create a U-Matrix visualization. Correct me if I am wrong but my understanding is the following: - for each unit/node, we compute the average or sum of the distances between the node and its neighbours (from 2 for the corners to 3 at the edges and 4 for the others) - we then represent those aggregated “surrounding” distances in the grid - it can be interpreted as follows (when bright is small distance and dark is large distance): a group of bright nodes surrounded by dark ones suggest a cluster</p>
<p>Am I right?</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>AI Response</strong></p>
<p>Yes, your understanding of the U-Matrix (Unified Distance Matrix) is correct! Let me confirm each point:</p>
<ol type="1">
<li>✓ For each node:
<ul>
<li>Calculate distances to immediate neighbors</li>
<li>Can have 2 neighbors (corners)</li>
<li>Can have 3 neighbors (edges)</li>
<li>Can have 4 neighbors (interior nodes)</li>
</ul></li>
<li>✓ Visualization shows:
<ul>
<li>Average/sum of distances to neighbors</li>
<li>Usually displayed as a heatmap</li>
</ul></li>
<li>✓ Interpretation:
<ul>
<li>Bright regions = similar nodes = potential cluster</li>
<li>Dark regions = dissimilar nodes = potential boundaries</li>
<li>Dark “barriers” between bright regions suggest cluster boundaries</li>
</ul></li>
</ol>
<p>Would you like to implement this visualization? We’ll need to: 1. Create a function to find neighbors for each node 2. Calculate distances between neighbors 3. Create the visualization</p>
<p>Which part would you like to tackle first?</p>
</div>
</div>
<div id="cell-93" class="cell">
<div class="sourceCode cell-code" id="cb78"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Test weights matrix (SOM)</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.array([</span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>    [[<span class="dv">1</span>], [<span class="dv">3</span>], [<span class="dv">1</span>]],</span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a>    [[<span class="dv">11</span>], [<span class="dv">4</span>], [<span class="dv">2</span>]],</span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a>    [[<span class="dv">7</span>], [<span class="dv">8</span>], [<span class="dv">5</span>]]])</span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-7"><a href="#cb78-7" aria-hidden="true" tabindex="-1"></a>np.squeeze(x)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>array([[ 1,  3,  1],
       [11,  4,  2],
       [ 7,  8,  5]])</code></pre>
</div>
</div>
<p>I first attempted an approach using vectorization, padded and masked version of the weights. I am finding cluncky and much less readable than a more straightforward iteration throughout the weights.</p>
<div id="cell-95" class="cell">
<div class="sourceCode cell-code" id="cb80"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="co"># For instance a right-padded version of test weights matrix</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>x_right <span class="op">=</span> np.pad(x, ((<span class="dv">0</span>,<span class="dv">0</span>), (<span class="dv">0</span>,<span class="dv">1</span>), (<span class="dv">0</span>,<span class="dv">0</span>)), mode<span class="op">=</span><span class="st">'edge'</span>)</span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a>d_right <span class="op">=</span> np.linalg.norm(x_right[:,<span class="dv">1</span>:] <span class="op">-</span> x_right[:,<span class="dv">0</span>:<span class="op">-</span><span class="dv">1</span>], axis<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a>d_right</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>array([[2., 2., 0.],
       [7., 2., 0.],
       [1., 3., 0.]])</code></pre>
</div>
</div>
<p>Below, an iterative approach:</p>
<div id="cell-97" class="cell">
<div class="sourceCode cell-code" id="cb82"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Neighbors offsets</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>nbr_offsets <span class="op">=</span> [</span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a>    (<span class="op">-</span><span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>), (<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>), (<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>),  <span class="co"># top-left, top, top-right</span></span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>),          (<span class="dv">0</span>,<span class="dv">1</span>),   <span class="co"># left, right</span></span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>),  (<span class="dv">1</span>,<span class="dv">0</span>),  (<span class="dv">1</span>,<span class="dv">1</span>)    <span class="co"># bottom-left, bottom, bottom-right</span></span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-98" class="cell">
<div class="sourceCode cell-code" id="cb83"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a>n_rows, n_cols <span class="op">=</span> <span class="dv">3</span>,<span class="dv">3</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a>pos <span class="op">=</span> (<span class="dv">0</span>,<span class="dv">1</span>)</span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a>_ws <span class="op">=</span> []</span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a>ds <span class="op">=</span> []</span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> dr,dc <span class="kw">in</span> nbr_offsets:</span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true" tabindex="-1"></a>    r,c <span class="op">=</span> pos</span>
<span id="cb83-7"><a href="#cb83-7" aria-hidden="true" tabindex="-1"></a>    nbr_r, nbr_c <span class="op">=</span> r<span class="op">+</span>dr, c<span class="op">+</span>dc</span>
<span id="cb83-8"><a href="#cb83-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (nbr_r<span class="op">&gt;=</span><span class="dv">0</span> <span class="kw">and</span> nbr_r<span class="op">&lt;</span>n_rows) <span class="kw">and</span> (nbr_c<span class="op">&gt;=</span><span class="dv">0</span> <span class="kw">and</span> nbr_c<span class="op">&lt;</span>n_cols):</span>
<span id="cb83-9"><a href="#cb83-9" aria-hidden="true" tabindex="-1"></a>        w <span class="op">=</span> <span class="dv">1</span><span class="op">/</span>np.sqrt(dr<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> dc<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb83-10"><a href="#cb83-10" aria-hidden="true" tabindex="-1"></a>        _ws.append(w)</span>
<span id="cb83-11"><a href="#cb83-11" aria-hidden="true" tabindex="-1"></a>        d <span class="op">=</span> np.linalg.norm(x[r, c] <span class="op">-</span> x[nbr_r, nbr_c], axis<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb83-12"><a href="#cb83-12" aria-hidden="true" tabindex="-1"></a>        ds.append(d)</span>
<span id="cb83-13"><a href="#cb83-13" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f'distance between: </span><span class="sc">{</span>r<span class="sc">,</span>c<span class="sc">}</span><span class="ss"> and </span><span class="sc">{</span>nbr_r<span class="sc">,</span> nbr_c<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>d<span class="sc">}</span><span class="ss"> with weight: </span><span class="sc">{</span>w<span class="sc">:.2f}</span><span class="ss">'</span>)</span>
<span id="cb83-14"><a href="#cb83-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-15"><a href="#cb83-15" aria-hidden="true" tabindex="-1"></a>np.average(ds, weights<span class="op">=</span>_ws)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>distance between: (0, 1) and (0, 0): 2.0 with weight: 1.00
distance between: (0, 1) and (0, 2): 2.0 with weight: 1.00
distance between: (0, 1) and (1, 0): 8.0 with weight: 0.71
distance between: (0, 1) and (1, 1): 1.0 with weight: 1.00
distance between: (0, 1) and (1, 2): 1.0 with weight: 0.71</code></pre>
</div>
<div class="cell-output cell-output-display">
<pre><code>2.5744021828816153</code></pre>
</div>
</div>
<div id="cell-99" class="cell">
<div class="sourceCode cell-code" id="cb86"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> is_in_bounds(row_idx, col_idx, ws):</span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>    n_rows, n_cols <span class="op">=</span> ws.shape[:<span class="dv">2</span>]</span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span>  (row_idx<span class="op">&gt;=</span><span class="dv">0</span> <span class="kw">and</span> row_idx<span class="op">&lt;</span>n_rows) <span class="kw">and</span> (col_idx<span class="op">&gt;=</span><span class="dv">0</span> <span class="kw">and</span> col_idx<span class="op">&lt;</span>n_cols) </span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(is_in_bounds(<span class="dv">0</span>,<span class="dv">0</span>,x))</span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(is_in_bounds(<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>,x))</span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(is_in_bounds(<span class="dv">4</span>,<span class="dv">0</span>,x))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>True
False
False</code></pre>
</div>
</div>
<div id="cell-100" class="cell">
<div class="sourceCode cell-code" id="cb88"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> nbr_dist(pos, ws, dist_fn, nbr_offsets<span class="op">=</span>nbr_offsets):</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>    weights <span class="op">=</span> []</span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>    ds <span class="op">=</span> []</span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> dr,dc <span class="kw">in</span> nbr_offsets:</span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a>        r,c <span class="op">=</span> pos</span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a>        nbr_r, nbr_c <span class="op">=</span> r<span class="op">+</span>dr, c<span class="op">+</span>dc</span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> is_in_bounds(nbr_r, nbr_c, ws):</span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true" tabindex="-1"></a>            weights.append(<span class="dv">1</span><span class="op">/</span>np.sqrt(dr<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> dc<span class="op">**</span><span class="dv">2</span>))</span>
<span id="cb88-9"><a href="#cb88-9" aria-hidden="true" tabindex="-1"></a>            d <span class="op">=</span> dist_fn(ws[r, c] <span class="op">-</span> ws[nbr_r, nbr_c], axis<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb88-10"><a href="#cb88-10" aria-hidden="true" tabindex="-1"></a>            ds.append(d)</span>
<span id="cb88-11"><a href="#cb88-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-12"><a href="#cb88-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.average(ds, weights<span class="op">=</span>weights)</span>
<span id="cb88-13"><a href="#cb88-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-14"><a href="#cb88-14" aria-hidden="true" tabindex="-1"></a>pos <span class="op">=</span> (<span class="dv">0</span>,<span class="dv">1</span>)</span>
<span id="cb88-15"><a href="#cb88-15" aria-hidden="true" tabindex="-1"></a>nbr_dist(pos, x, np.linalg.norm)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>2.5744021828816153</code></pre>
</div>
</div>
<div id="cell-101" class="cell">
<div class="sourceCode cell-code" id="cb90"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a>np.squeeze(x)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>array([[ 1,  3,  1],
       [11,  4,  2],
       [ 7,  8,  5]])</code></pre>
</div>
</div>
<div id="cell-102" class="cell">
<div class="sourceCode cell-code" id="cb92"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a>u_matrix <span class="op">=</span> np.zeros(x.shape[:<span class="dv">2</span>])</span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, j <span class="kw">in</span> np.ndindex(x.shape[:<span class="dv">2</span>]):</span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a>    u_matrix[i,j] <span class="op">=</span> nbr_dist((i,j), x, np.linalg.norm)</span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a>u_matrix</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>array([[5.21638838, 2.57440218, 1.89180581],
       [6.51943414, 3.08578644, 2.48056586],
       [2.63060194, 3.25402494, 2.47759225]])</code></pre>
</div>
</div>
<div id="cell-103" class="cell">
<div class="sourceCode cell-code" id="cb94"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_umatrix(weights, dist_fn<span class="op">=</span>np.linalg.norm):</span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>    u_matrix <span class="op">=</span> np.zeros(weights.shape[:<span class="dv">2</span>])</span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, j <span class="kw">in</span> np.ndindex(weights.shape[:<span class="dv">2</span>]):</span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a>        u_matrix[i,j] <span class="op">=</span> nbr_dist((i,j), weights, dist_fn)</span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> u_matrix</span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-7"><a href="#cb94-7" aria-hidden="true" tabindex="-1"></a>calculate_umatrix(x)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>array([[5.21638838, 2.57440218, 1.89180581],
       [6.51943414, 3.08578644, 2.48056586],
       [2.63060194, 3.25402494, 2.47759225]])</code></pre>
</div>
</div>
<div id="cell-104" class="cell">
<div class="sourceCode cell-code" id="cb96"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_umatrix(weights, cmap<span class="op">=</span><span class="st">'viridis_r'</span>, figsize<span class="op">=</span>(<span class="dv">2</span>,<span class="dv">2</span>)):</span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a>    umatrix <span class="op">=</span> calculate_umatrix(weights)</span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a>    plt.figure(figsize<span class="op">=</span>figsize)</span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a>    plt.imshow(umatrix, cmap<span class="op">=</span>cmap, interpolation<span class="op">=</span><span class="st">'nearest'</span>)</span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true" tabindex="-1"></a>    plt.colorbar(label<span class="op">=</span><span class="st">'Average distance to neighbors'</span>)</span>
<span id="cb96-6"><a href="#cb96-6" aria-hidden="true" tabindex="-1"></a>    plt.title(<span class="st">'U-Matrix'</span>)</span>
<span id="cb96-7"><a href="#cb96-7" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb96-8"><a href="#cb96-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-9"><a href="#cb96-9" aria-hidden="true" tabindex="-1"></a>plot_umatrix(ws)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="how-was-it-created_files/figure-html/cell-51-output-1.png" width="217" height="178" class="figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="ii.3-naive-training-loop" class="level3">
<h3 class="anchored" data-anchor-id="ii.3-naive-training-loop">II.3 Naive training loop</h3>
<div id="cell-106" class="cell">
<div class="sourceCode cell-code" id="cb97"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tqdm <span class="im">import</span> trange, tqdm</span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a>n_epochs <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> epoch <span class="kw">in</span> tqdm(<span class="bu">range</span>(n_epochs)):</span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a>    X_ <span class="op">=</span> np.random.permutation(X)</span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x <span class="kw">in</span> X:</span>
<span id="cb97-6"><a href="#cb97-6" aria-hidden="true" tabindex="-1"></a>        kernelf_fn <span class="op">=</span> partial(gaussian_fn, sigma<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb97-7"><a href="#cb97-7" aria-hidden="true" tabindex="-1"></a>        ws <span class="op">=</span> update(x, ws, dist_fn, kernel_fn, lr<span class="op">=</span><span class="fl">0.1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>
  0%|          | 0/20 [00:00&lt;?, ?it/s]
  5%|5         | 1/20 [00:00&lt;00:02,  7.25it/s]
 10%|#         | 2/20 [00:00&lt;00:02,  7.38it/s]
 15%|#5        | 3/20 [00:00&lt;00:02,  7.51it/s]
 20%|##        | 4/20 [00:00&lt;00:02,  7.57it/s]
 25%|##5       | 5/20 [00:00&lt;00:01,  7.55it/s]
 30%|###       | 6/20 [00:00&lt;00:01,  7.54it/s]
 35%|###5      | 7/20 [00:00&lt;00:01,  7.58it/s]
 40%|####      | 8/20 [00:01&lt;00:01,  7.58it/s]
 45%|####5     | 9/20 [00:01&lt;00:01,  7.58it/s]
 50%|#####     | 10/20 [00:01&lt;00:01,  7.54it/s]
 55%|#####5    | 11/20 [00:01&lt;00:01,  7.56it/s]
 60%|######    | 12/20 [00:01&lt;00:01,  7.57it/s]
 65%|######5   | 13/20 [00:01&lt;00:00,  7.55it/s]
 70%|#######   | 14/20 [00:01&lt;00:00,  7.50it/s]
 75%|#######5  | 15/20 [00:01&lt;00:00,  7.54it/s]
 80%|########  | 16/20 [00:02&lt;00:00,  7.58it/s]
 85%|########5 | 17/20 [00:02&lt;00:00,  7.55it/s]
 90%|######### | 18/20 [00:02&lt;00:00,  7.54it/s]
 95%|#########5| 19/20 [00:02&lt;00:00,  7.55it/s]
100%|##########| 20/20 [00:02&lt;00:00,  7.57it/s]
100%|##########| 20/20 [00:02&lt;00:00,  7.54it/s]</code></pre>
</div>
</div>
<div id="cell-107" class="cell">
<div class="sourceCode cell-code" id="cb99"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a>plot_umatrix(ws)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="how-was-it-created_files/figure-html/cell-53-output-1.png" width="217" height="178" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p><strong>AI Prompt</strong></p>
<p>Great, we clearly see the 3 clusters captured. Now I’d like to implement some of the metrics: Quantization Error and Topographic Error so that to log it after every epoch ideally.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>AI Response</strong></p>
<p>Let’s implement these two metrics:</p>
<ol type="1">
<li>Quantization Error (QE):
<ul>
<li>Average distance between each input vector and its BMU</li>
<li>Measures how well the map represents the input space</li>
</ul></li>
<li>Topographic Error (TE):
<ul>
<li>Proportion of data vectors for which 1st and 2nd BMUs are not adjacent</li>
<li>Measures preservation of topology</li>
</ul></li>
</ol>
<p>Would you like to implement these metrics one at a time? We can start with the Quantization Error since it’s simpler and uses components we already have (distance function and BMU finding).</p>
<p>Which metric would you prefer to tackle first?</p>
</div>
</div>
</section>
<section id="ii.4-quantization-error-qe" class="level3">
<h3 class="anchored" data-anchor-id="ii.4-quantization-error-qe">II.4 Quantization Error (QE)</h3>
<p><strong>AI Prompt</strong></p>
<p>Here is my understanding and plan to calculate QE (Quantization Error) For each sample of the training set we have to: - identify its bmu (we already have a function for this) - calculate input/sample distance from its bmu (we have this already) - take the mean of those distances</p>
<p>Actually when we search the bmu, we take the <code>argmin</code> of the distances between each node/unit and the input. Here, we don’t need to search the bmu, taking the min of the distances would already solve our problem.</p>
<p>In summary, I think we already have all elements. What do you think?</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>AI Response</strong></p>
<p>Yes, your understanding is perfect! You’ve made a very astute observation about reusing the distance calculation and just needing the minimum value rather than its position.</p>
<p>For each input x, we: 1. Calculate distances to all nodes (using our <code>dist_fn</code>) 2. Take the minimum distance (don’t need <code>argmin</code>, just <code>min</code>) 3. Average these minimum distances across all inputs</p>
<p>Would you like to try implementing this as a function? We can use numpy’s vectorized operations to make it efficient. Would you like to try it yourself first, or would you like some guidance?</p>
</div>
</div>
<div id="cell-113" class="cell">
<div class="sourceCode cell-code" id="cb100"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a>qe_err <span class="op">=</span> <span class="kw">lambda</span> X,ws: np.array([dist_fn(x, ws).<span class="bu">min</span>() <span class="cf">for</span> x <span class="kw">in</span> X]).mean()</span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a>qe_err(X,ws)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>0.14465875369726378</code></pre>
</div>
</div>
<div id="cell-114" class="cell">
<div class="sourceCode cell-code" id="cb102"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a>n_samples <span class="op">=</span> <span class="bu">len</span>(X)</span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a>grid_sz <span class="op">=</span> (n_nodes(n_samples),n_nodes(n_samples))</span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a>ws <span class="op">=</span> np.random.randn(<span class="op">*</span>grid_sz, X.shape[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true" tabindex="-1"></a>qe_errs <span class="op">=</span> []</span>
<span id="cb102-6"><a href="#cb102-6" aria-hidden="true" tabindex="-1"></a>n_epochs <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb102-7"><a href="#cb102-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> epoch <span class="kw">in</span> <span class="bu">range</span>(n_epochs):</span>
<span id="cb102-8"><a href="#cb102-8" aria-hidden="true" tabindex="-1"></a>    X_ <span class="op">=</span> np.random.permutation(X)</span>
<span id="cb102-9"><a href="#cb102-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x <span class="kw">in</span> X:</span>
<span id="cb102-10"><a href="#cb102-10" aria-hidden="true" tabindex="-1"></a>        kernelf_fn <span class="op">=</span> partial(gaussian_fn, sigma<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb102-11"><a href="#cb102-11" aria-hidden="true" tabindex="-1"></a>        ws <span class="op">=</span> update(x, ws, dist_fn, kernel_fn, lr<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb102-12"><a href="#cb102-12" aria-hidden="true" tabindex="-1"></a>    qe_errs.append(qe_err(X, ws))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-115" class="cell">
<div class="sourceCode cell-code" id="cb103"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">3</span>, <span class="dv">2</span>))</span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a>plt.plot(<span class="bu">range</span>(<span class="dv">1</span>, n_epochs<span class="op">+</span><span class="dv">1</span>), qe_errs, lw<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Epoch'</span>)</span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Quantization Error'</span>)</span>
<span id="cb103-6"><a href="#cb103-6" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'SOM Training Progress'</span>)</span>
<span id="cb103-7"><a href="#cb103-7" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="how-was-it-created_files/figure-html/cell-56-output-1.png" width="301" height="201" class="figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="ii.5-topographic-error-te" class="level3">
<h3 class="anchored" data-anchor-id="ii.5-topographic-error-te">II.5 Topographic Error (TE)</h3>
<p><strong>AI Prompt</strong></p>
<p>Let me give you my understanding of the Topographic Error metric. For each sample, - we take is best matching unit (bmu1) and its second best matching unit (bmu2) - if bmu2 is not adjacent (left, right, bottom, up, bottom right, …) to bmu1 we count it as one error</p>
<p>TE is simply the percentage of the number of such errors over the total number of training samples. Is my understanding correct?</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>AI Response</strong></p>
<p>Yes, your understanding of Topographic Error is exactly right! Let’s break down the key points:</p>
<ol type="1">
<li>For each input sample:
<ul>
<li>Find BMU (1st best)</li>
<li>Find second BMU (2nd best)</li>
<li>Check if they’re adjacent using our neighbor definition</li>
<li>Count as error if not adjacent</li>
</ul></li>
<li>Final TE = (number of errors) / (total samples)</li>
</ol>
<p>We already have most pieces: - Distance calculation - BMU finding - Neighbor definition (from U-Matrix implementation)</p>
<p>Would you like to create a function to: 1. Find the second-best BMU (we’ll need to modify our existing BMU code), or 2. Check if two positions are adjacent (we can use our <code>nbr_offsets</code> from earlier)</p>
<p>Which part would you like to tackle first?</p>
</div>
</div>
<p><strong>AI Prompt</strong></p>
<p>How could I find the index of the two closest units/element in a SOM/array? I could possibly identify the bmu using the function already available, reassign the value of this bmu to <code>np.inf</code> on a copy of the som and take the bmu again to get the second one. What do you think? It is likely we can do it in a more straightforward way, don’t you think?</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>AI Response</strong></p>
<p>Ah yes, there’s a more elegant way! We can use <code>np.argpartition()</code> which is specifically designed to find the k smallest (or largest) elements in an array. It’s more efficient than your suggested approach since:</p>
<ol type="1">
<li>It doesn’t require making a copy</li>
<li>It only partially sorts the array (just enough to find the k smallest values)</li>
<li>It’s a single operation</li>
</ol>
<p>Would you like to explore how to use <code>np.argpartition()</code> to find the indices of the two smallest distances? We can then use <code>np.unravel_index()</code> like we did before to convert these to grid coordinates.</p>
<p>Would you like to try this approach?</p>
</div>
</div>
<p><strong>AI Prompt</strong></p>
<p>Can you explain how to retrieve the two smallest value in a 2D numpy array using np.argpartition?</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>AI Response</strong></p>
<p>Let’s break this down with a simple example:</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a sample 2D array</span></span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> np.array([[<span class="dv">5</span>, <span class="dv">2</span>, <span class="dv">3</span>],</span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a>                [<span class="dv">1</span>, <span class="dv">7</span>, <span class="dv">4</span>],</span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true" tabindex="-1"></a>                [<span class="dv">6</span>, <span class="dv">8</span>, <span class="dv">9</span>]])</span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-6"><a href="#cb104-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Get indices of 2 smallest values using np.argpartition</span></span>
<span id="cb104-7"><a href="#cb104-7" aria-hidden="true" tabindex="-1"></a><span class="co"># We first flatten the array, then find indices of 2 smallest values</span></span>
<span id="cb104-8"><a href="#cb104-8" aria-hidden="true" tabindex="-1"></a>flat_indices <span class="op">=</span> np.argpartition(arr.flatten(), <span class="dv">2</span>)[:<span class="dv">2</span>]</span>
<span id="cb104-9"><a href="#cb104-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-10"><a href="#cb104-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert flat indices back to 2D coordinates using unravel_index</span></span>
<span id="cb104-11"><a href="#cb104-11" aria-hidden="true" tabindex="-1"></a>indices_2d <span class="op">=</span> np.unravel_index(flat_indices, arr.shape)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Would you like to try this with a small example to see how it works? We can then adapt it for our SOM distances.</p>
</div>
</div>
<div id="cell-123" class="cell">
<div class="sourceCode cell-code" id="cb105"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a sample 2D array</span></span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> np.array([[<span class="dv">5</span>, <span class="dv">2</span>, <span class="dv">3</span>],</span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a>                [<span class="dv">1</span>, <span class="dv">7</span>, <span class="dv">4</span>],</span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a>                [<span class="dv">6</span>, <span class="dv">8</span>, <span class="dv">9</span>]])</span>
<span id="cb105-5"><a href="#cb105-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-6"><a href="#cb105-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Get indices of 2 smallest values using np.argpartition</span></span>
<span id="cb105-7"><a href="#cb105-7" aria-hidden="true" tabindex="-1"></a><span class="co"># We first flatten the array, then find indices of 2 smallest values</span></span>
<span id="cb105-8"><a href="#cb105-8" aria-hidden="true" tabindex="-1"></a>flat_indices <span class="op">=</span> np.argpartition(arr.flatten(), <span class="dv">2</span>)[:<span class="dv">2</span>]</span>
<span id="cb105-9"><a href="#cb105-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'flat indices: </span><span class="sc">{</span>flat_indices<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb105-10"><a href="#cb105-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-11"><a href="#cb105-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert flat indices back to 2D coordinates using unravel_index</span></span>
<span id="cb105-12"><a href="#cb105-12" aria-hidden="true" tabindex="-1"></a>rows_idx, cols_idx <span class="op">=</span> np.unravel_index(flat_indices, arr.shape)</span>
<span id="cb105-13"><a href="#cb105-13" aria-hidden="true" tabindex="-1"></a><span class="bu">list</span>(<span class="bu">zip</span>(rows_idx, cols_idx))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>flat indices: [3 1]</code></pre>
</div>
<div class="cell-output cell-output-display">
<pre><code>[(1, 0), (0, 1)]</code></pre>
</div>
</div>
<div id="cell-124" class="cell">
<div class="sourceCode cell-code" id="cb108"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.array([</span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a>    [[<span class="dv">1</span>], [<span class="dv">3</span>], [<span class="dv">1</span>]],</span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a>    [[<span class="dv">11</span>], [<span class="dv">4</span>], [<span class="dv">2</span>]],</span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true" tabindex="-1"></a>    [[<span class="dv">7</span>], [<span class="dv">8</span>], [<span class="dv">5</span>]]])</span>
<span id="cb108-5"><a href="#cb108-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-6"><a href="#cb108-6" aria-hidden="true" tabindex="-1"></a>dist_fn(np.array(<span class="fl">3.9</span>), x)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>array([[2.9, 0.9, 2.9],
       [7.1, 0.1, 1.9],
       [3.1, 4.1, 1.1]])</code></pre>
</div>
</div>
<div id="cell-125" class="cell">
<div class="sourceCode cell-code" id="cb110"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> dist_fn(np.array(<span class="fl">3.9</span>), x)</span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a>flat_indices <span class="op">=</span> np.argpartition(arr.flatten(), <span class="dv">2</span>)[:<span class="dv">2</span>]</span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a>rows_idx, cols_idx <span class="op">=</span> np.unravel_index(flat_indices, arr.shape)</span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a><span class="bu">list</span>(<span class="bu">zip</span>(rows_idx, cols_idx))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>[(1, 1), (0, 1)]</code></pre>
</div>
</div>
<p>Actually by checking directly the difference of rows and cols indices returned for the two closest elements we can already check if they are adjacent or not (if any of the difference of the two &gt; 1).</p>
<div id="cell-127" class="cell">
<div class="sourceCode cell-code" id="cb112"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> dist_fn(np.array(<span class="fl">3.9</span>), x)</span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a>flat_indices <span class="op">=</span> np.argpartition(arr.flatten(), <span class="dv">2</span>)[:<span class="dv">2</span>]</span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a>indices <span class="op">=</span> np.unravel_index(flat_indices, arr.shape)</span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true" tabindex="-1"></a>indices</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>(array([1, 0]), array([1, 1]))</code></pre>
</div>
</div>
<div id="cell-128" class="cell">
<div class="sourceCode cell-code" id="cb114"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="bu">any</span>([np.<span class="bu">abs</span>(x<span class="op">-</span>y)<span class="op">&gt;</span> <span class="dv">1</span> <span class="cf">for</span> x,y <span class="kw">in</span> indices])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>False</code></pre>
</div>
</div>
<p>Ok I think we have everything to implement the TE error.</p>
<div id="cell-130" class="cell">
<div class="sourceCode cell-code" id="cb116"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a>n_errs <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> x <span class="kw">in</span> X:</span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a>    arr <span class="op">=</span> dist_fn(x, ws)</span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a>    flat_indices <span class="op">=</span> np.argpartition(arr.flatten(), <span class="dv">2</span>)[:<span class="dv">2</span>]</span>
<span id="cb116-5"><a href="#cb116-5" aria-hidden="true" tabindex="-1"></a>    indices <span class="op">=</span> np.unravel_index(flat_indices, arr.shape)</span>
<span id="cb116-6"><a href="#cb116-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">any</span>([np.<span class="bu">abs</span>(x<span class="op">-</span>y)<span class="op">&gt;</span> <span class="dv">1</span> <span class="cf">for</span> x,y <span class="kw">in</span> indices]): n_errs<span class="op">+=</span><span class="dv">1</span></span>
<span id="cb116-7"><a href="#cb116-7" aria-hidden="true" tabindex="-1"></a>n_errs</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>38</code></pre>
</div>
</div>
<div id="cell-131" class="cell">
<div class="sourceCode cell-code" id="cb118"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> te_err(X, ws, dist_fn<span class="op">=</span>dist_fn):</span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a>    n_errs <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x <span class="kw">in</span> X:</span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true" tabindex="-1"></a>        arr <span class="op">=</span> dist_fn(x, ws)</span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true" tabindex="-1"></a>        flat_indices <span class="op">=</span> np.argpartition(arr.flatten(), <span class="dv">2</span>)[:<span class="dv">2</span>]</span>
<span id="cb118-6"><a href="#cb118-6" aria-hidden="true" tabindex="-1"></a>        indices <span class="op">=</span> np.unravel_index(flat_indices, arr.shape)</span>
<span id="cb118-7"><a href="#cb118-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">any</span>([np.<span class="bu">abs</span>(x<span class="op">-</span>y)<span class="op">&gt;</span> <span class="dv">1</span> <span class="cf">for</span> x,y <span class="kw">in</span> indices]): n_errs<span class="op">+=</span><span class="dv">1</span></span>
<span id="cb118-8"><a href="#cb118-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">100</span><span class="op">*</span>n_errs <span class="op">/</span> <span class="bu">len</span>(X)</span>
<span id="cb118-9"><a href="#cb118-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-10"><a href="#cb118-10" aria-hidden="true" tabindex="-1"></a>te_err(X, ws)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>3.8</code></pre>
</div>
</div>
<div id="cell-132" class="cell">
<div class="sourceCode cell-code" id="cb120"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a>n_samples <span class="op">=</span> <span class="bu">len</span>(X)</span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a>grid_sz <span class="op">=</span> (n_nodes(n_samples),n_nodes(n_samples))</span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a>ws <span class="op">=</span> np.random.randn(<span class="op">*</span>grid_sz, X.shape[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-5"><a href="#cb120-5" aria-hidden="true" tabindex="-1"></a>te_errs <span class="op">=</span> []</span>
<span id="cb120-6"><a href="#cb120-6" aria-hidden="true" tabindex="-1"></a>n_epochs <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb120-7"><a href="#cb120-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> epoch <span class="kw">in</span> <span class="bu">range</span>(n_epochs):</span>
<span id="cb120-8"><a href="#cb120-8" aria-hidden="true" tabindex="-1"></a>    X_ <span class="op">=</span> np.random.permutation(X)</span>
<span id="cb120-9"><a href="#cb120-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x <span class="kw">in</span> X:</span>
<span id="cb120-10"><a href="#cb120-10" aria-hidden="true" tabindex="-1"></a>        kernelf_fn <span class="op">=</span> partial(gaussian_fn, sigma<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb120-11"><a href="#cb120-11" aria-hidden="true" tabindex="-1"></a>        ws <span class="op">=</span> update(x, ws, dist_fn, kernel_fn, lr<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb120-12"><a href="#cb120-12" aria-hidden="true" tabindex="-1"></a>    te_errs.append(te_err(X, ws))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-133" class="cell">
<div class="sourceCode cell-code" id="cb121"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">3</span>, <span class="dv">2</span>))</span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a>plt.plot(<span class="bu">range</span>(<span class="dv">1</span>, n_epochs<span class="op">+</span><span class="dv">1</span>), te_errs, lw<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb121-4"><a href="#cb121-4" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Epoch'</span>)</span>
<span id="cb121-5"><a href="#cb121-5" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Topographic Error'</span>)</span>
<span id="cb121-6"><a href="#cb121-6" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'SOM Training Progress'</span>)</span>
<span id="cb121-7"><a href="#cb121-7" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="how-was-it-created_files/figure-html/cell-65-output-1.png" width="302" height="201" class="figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="ii.6-lr-and-σ-schedulers" class="level3">
<h3 class="anchored" data-anchor-id="ii.6-lr-and-σ-schedulers">II.6 LR and σ schedulers</h3>
<p><strong>AI Prompt</strong></p>
<p>We want a scheduler that given current step (epoch?) will decay both the learning rate and sigma for instance. Now I have a question. What do you think, should I make it flexible enough so that we could potentially decay them even before the end of an epoch?</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>AI Response</strong></p>
<p>That’s a great question! Yes, making the scheduler flexible enough to handle both epoch-level and sample-level updates would be more versatile, because:</p>
<ol type="1">
<li>Different SOM implementations might need:
<ul>
<li>Epoch-level decay (simpler, more common)</li>
<li>Mini-batch decay</li>
<li>Sample-level decay (finest granularity)</li>
</ul></li>
<li>Some papers suggest that fine-grained decay can be beneficial for:
<ul>
<li>Better convergence</li>
<li>More precise neighborhood adaptation</li>
<li>Handling streaming data</li>
</ul></li>
</ol>
<p>Would you like to design a scheduler interface that can handle both cases? We could: 1. Make it step-based rather than epoch-based 2. Let the user define what constitutes a “step” 3. Allow different decay functions</p>
<p>Would you like to explore any of these aspects first?</p>
</div>
</div>
<p><strong>AI Prompt</strong></p>
<p>Letting users define what constitues a “step” (e.g every n samples) sounds more flexible I think. Let’s implement it.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>AI Response</strong></p>
<p>Good choice! Let’s design a flexible scheduler. We’ll need to:</p>
<ol type="1">
<li>Track:
<ul>
<li>Current step number</li>
<li>Initial value (lr or sigma)</li>
<li>Decay function</li>
</ul></li>
<li>Allow users to:
<ul>
<li>Define custom decay functions</li>
<li>Specify when to step (sample, batch, epoch)</li>
</ul></li>
</ol>
<p>Would you like to start with implementing a basic scheduler class or first explore some common decay functions?</p>
<p>For decay functions, we could implement common ones like: - Linear decay - Exponential decay - Power decay (polynomial)</p>
<p>Which would you prefer to tackle first?</p>
</div>
</div>
<p><strong>AI Prompt</strong></p>
<p>I step_sz means the every number of samples requires before updating a value. How to name the total number of samples*number of epochs where we reach the end of the decay?</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>AI Response</strong></p>
<p>In scheduling contexts, this is often called the “total_steps” or “max_steps” - it represents the total number of update opportunities over the entire training process.</p>
<p>So if we have: - n_samples = 1000 - n_epochs = 20 - step_size = 10 (update every 10 samples)</p>
<p>Then:</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a>total_steps <span class="op">=</span> (n_samples <span class="op">*</span> n_epochs) <span class="op">//</span> step_size</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Would you like to use one of these names, or do you have another preference for what to call this parameter? We could also call it “decay_steps” or “schedule_length” if you think that would be clearer.</p>
</div>
</div>
<div id="cell-141" class="cell">
<div class="sourceCode cell-code" id="cb123"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a><span class="dv">3000</span><span class="op">//</span>step_sz</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>0</code></pre>
</div>
</div>
<div id="cell-142" class="cell">
<div class="sourceCode cell-code" id="cb125"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> exp_sched(start_val, end_val, i, n_steps):</span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a>    decay <span class="op">=</span> <span class="op">-</span>np.log(end_val<span class="op">/</span>start_val)<span class="op">/</span>n_steps</span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> start_val <span class="op">*</span> np.exp(<span class="op">-</span>decay <span class="op">*</span> i)</span>
<span id="cb125-4"><a href="#cb125-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-5"><a href="#cb125-5" aria-hidden="true" tabindex="-1"></a>step_sz <span class="op">=</span> <span class="dv">5000</span></span>
<span id="cb125-6"><a href="#cb125-6" aria-hidden="true" tabindex="-1"></a>n_samples <span class="op">=</span> <span class="dv">10_000</span> </span>
<span id="cb125-7"><a href="#cb125-7" aria-hidden="true" tabindex="-1"></a>n_epochs <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb125-8"><a href="#cb125-8" aria-hidden="true" tabindex="-1"></a>n_steps <span class="op">=</span> n_epochs<span class="op">*</span>n_samples<span class="op">//</span>step_sz</span>
<span id="cb125-9"><a href="#cb125-9" aria-hidden="true" tabindex="-1"></a>start_v, end_v <span class="op">=</span> <span class="dv">10</span>, <span class="dv">1</span></span>
<span id="cb125-10"><a href="#cb125-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-11"><a href="#cb125-11" aria-hidden="true" tabindex="-1"></a>step_idx <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb125-12"><a href="#cb125-12" aria-hidden="true" tabindex="-1"></a>v <span class="op">=</span> start_v</span>
<span id="cb125-13"><a href="#cb125-13" aria-hidden="true" tabindex="-1"></a>vs <span class="op">=</span> []</span>
<span id="cb125-14"><a href="#cb125-14" aria-hidden="true" tabindex="-1"></a>steps <span class="op">=</span> []</span>
<span id="cb125-15"><a href="#cb125-15" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_epochs):</span>
<span id="cb125-16"><a href="#cb125-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n_samples):</span>
<span id="cb125-17"><a href="#cb125-17" aria-hidden="true" tabindex="-1"></a>        total_samples <span class="op">=</span> i<span class="op">*</span>n_samples <span class="op">+</span> j</span>
<span id="cb125-18"><a href="#cb125-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> total_samples <span class="op">%</span> step_sz <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb125-19"><a href="#cb125-19" aria-hidden="true" tabindex="-1"></a>            v <span class="op">=</span> exp_sched(start_v, end_v, step_idx, n_steps)</span>
<span id="cb125-20"><a href="#cb125-20" aria-hidden="true" tabindex="-1"></a>            vs.append(v)</span>
<span id="cb125-21"><a href="#cb125-21" aria-hidden="true" tabindex="-1"></a>            steps.append(step_idx)</span>
<span id="cb125-22"><a href="#cb125-22" aria-hidden="true" tabindex="-1"></a>            step_idx<span class="op">+=</span><span class="dv">1</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-143" class="cell">
<div class="sourceCode cell-code" id="cb126"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">2</span>, <span class="dv">1</span>))</span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a>plt.plot(steps, vs, lw<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb126-4"><a href="#cb126-4" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Sample index'</span>)</span>
<span id="cb126-5"><a href="#cb126-5" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Value'</span>)</span>
<span id="cb126-6"><a href="#cb126-6" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Exponential Decay Schedule'</span>)</span>
<span id="cb126-7"><a href="#cb126-7" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="how-was-it-created_files/figure-html/cell-68-output-1.png" width="217" height="146" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="cell-144" class="cell">
<div class="sourceCode cell-code" id="cb127"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> fastcore.<span class="bu">all</span> <span class="im">import</span> <span class="op">*</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-145" class="cell">
<div class="sourceCode cell-code" id="cb128"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Scheduler:</span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, start_val, end_val, step_size, </span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true" tabindex="-1"></a>                 n_samples, n_epochs, decay_fn<span class="op">=</span>exp_sched):</span>
<span id="cb128-4"><a href="#cb128-4" aria-hidden="true" tabindex="-1"></a>        store_attr()</span>
<span id="cb128-5"><a href="#cb128-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.current_step <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb128-6"><a href="#cb128-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.current_value <span class="op">=</span> start_val</span>
<span id="cb128-7"><a href="#cb128-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.total_steps <span class="op">=</span> (n_samples <span class="op">*</span> n_epochs) <span class="op">//</span> step_size</span>
<span id="cb128-8"><a href="#cb128-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb128-9"><a href="#cb128-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> step(<span class="va">self</span>, total_samples):</span>
<span id="cb128-10"><a href="#cb128-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> total_samples <span class="op">%</span> <span class="va">self</span>.step_size <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb128-11"><a href="#cb128-11" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.current_value <span class="op">=</span> <span class="va">self</span>.decay_fn(</span>
<span id="cb128-12"><a href="#cb128-12" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.start_val, <span class="va">self</span>.end_val, </span>
<span id="cb128-13"><a href="#cb128-13" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.current_step, <span class="va">self</span>.total_steps</span>
<span id="cb128-14"><a href="#cb128-14" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb128-15"><a href="#cb128-15" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.current_step <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb128-16"><a href="#cb128-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.current_value</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="ii.7-advanced-training-loop-with-schedulers" class="level3">
<h3 class="anchored" data-anchor-id="ii.7-advanced-training-loop-with-schedulers">II.7 Advanced training loop with schedulers</h3>
<div id="cell-147" class="cell">
<div class="sourceCode cell-code" id="cb129"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a>n_samples <span class="op">=</span> <span class="bu">len</span>(X)</span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a>grid_sz <span class="op">=</span> (n_nodes(n_samples),n_nodes(n_samples))</span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a>ws <span class="op">=</span> np.random.randn(<span class="op">*</span>grid_sz, X.shape[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb129-4"><a href="#cb129-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-5"><a href="#cb129-5" aria-hidden="true" tabindex="-1"></a>step_size<span class="op">=</span><span class="dv">100</span></span>
<span id="cb129-6"><a href="#cb129-6" aria-hidden="true" tabindex="-1"></a>lr_scheduler <span class="op">=</span> Scheduler(start_val<span class="op">=</span><span class="dv">1</span>, end_val<span class="op">=</span><span class="fl">0.01</span>, step_size<span class="op">=</span>step_size, </span>
<span id="cb129-7"><a href="#cb129-7" aria-hidden="true" tabindex="-1"></a>                        n_samples<span class="op">=</span><span class="bu">len</span>(X), n_epochs<span class="op">=</span>n_epochs)</span>
<span id="cb129-8"><a href="#cb129-8" aria-hidden="true" tabindex="-1"></a>sigma_scheduler <span class="op">=</span> Scheduler(start_val<span class="op">=</span><span class="fl">6.0</span>, end_val<span class="op">=</span><span class="fl">1.</span>, step_size<span class="op">=</span>step_size, </span>
<span id="cb129-9"><a href="#cb129-9" aria-hidden="true" tabindex="-1"></a>                          n_samples<span class="op">=</span><span class="bu">len</span>(X), n_epochs<span class="op">=</span>n_epochs)</span>
<span id="cb129-10"><a href="#cb129-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-11"><a href="#cb129-11" aria-hidden="true" tabindex="-1"></a>n_epochs <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb129-12"><a href="#cb129-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Training loop</span></span>
<span id="cb129-13"><a href="#cb129-13" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> epoch <span class="kw">in</span> <span class="bu">range</span>(n_epochs):</span>
<span id="cb129-14"><a href="#cb129-14" aria-hidden="true" tabindex="-1"></a>    X_ <span class="op">=</span> np.random.permutation(X)</span>
<span id="cb129-15"><a href="#cb129-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, x <span class="kw">in</span> <span class="bu">enumerate</span>(X_):</span>
<span id="cb129-16"><a href="#cb129-16" aria-hidden="true" tabindex="-1"></a>        total_samples <span class="op">=</span> epoch <span class="op">*</span> <span class="bu">len</span>(X) <span class="op">+</span> i</span>
<span id="cb129-17"><a href="#cb129-17" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb129-18"><a href="#cb129-18" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Get current lr and sigma values</span></span>
<span id="cb129-19"><a href="#cb129-19" aria-hidden="true" tabindex="-1"></a>        lr <span class="op">=</span> lr_scheduler.step(total_samples)</span>
<span id="cb129-20"><a href="#cb129-20" aria-hidden="true" tabindex="-1"></a>        sigma <span class="op">=</span> sigma_scheduler.step(total_samples)</span>
<span id="cb129-21"><a href="#cb129-21" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb129-22"><a href="#cb129-22" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Update weights using current lr and sigma</span></span>
<span id="cb129-23"><a href="#cb129-23" aria-hidden="true" tabindex="-1"></a>        kernel_fn <span class="op">=</span> partial(gaussian_fn, sigma<span class="op">=</span>sigma)</span>
<span id="cb129-24"><a href="#cb129-24" aria-hidden="true" tabindex="-1"></a>        ws <span class="op">=</span> update(x, ws, dist_fn, kernel_fn, lr<span class="op">=</span>lr)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-148" class="cell">
<div class="sourceCode cell-code" id="cb130"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fit(X, ws, lr_scheduler, sigma_scheduler, n_epochs<span class="op">=</span><span class="dv">20</span>, shuffle<span class="op">=</span><span class="va">True</span>):</span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a>    qe_errs <span class="op">=</span> []</span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true" tabindex="-1"></a>    te_errs <span class="op">=</span> []</span>
<span id="cb130-4"><a href="#cb130-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> epoch <span class="kw">in</span> <span class="bu">range</span>(n_epochs):</span>
<span id="cb130-5"><a href="#cb130-5" aria-hidden="true" tabindex="-1"></a>        X_ <span class="op">=</span> np.random.permutation(X) <span class="cf">if</span> shuffle <span class="cf">else</span> X.copy()</span>
<span id="cb130-6"><a href="#cb130-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i, x <span class="kw">in</span> <span class="bu">enumerate</span>(X_):</span>
<span id="cb130-7"><a href="#cb130-7" aria-hidden="true" tabindex="-1"></a>            total_samples <span class="op">=</span> epoch <span class="op">*</span> <span class="bu">len</span>(X) <span class="op">+</span> i</span>
<span id="cb130-8"><a href="#cb130-8" aria-hidden="true" tabindex="-1"></a>            lr <span class="op">=</span> lr_scheduler.step(total_samples)</span>
<span id="cb130-9"><a href="#cb130-9" aria-hidden="true" tabindex="-1"></a>            sigma <span class="op">=</span> sigma_scheduler.step(total_samples)</span>
<span id="cb130-10"><a href="#cb130-10" aria-hidden="true" tabindex="-1"></a>            kernel_fn <span class="op">=</span> partial(gaussian_fn, sigma<span class="op">=</span>sigma)</span>
<span id="cb130-11"><a href="#cb130-11" aria-hidden="true" tabindex="-1"></a>            ws <span class="op">=</span> update(x, ws, dist_fn, kernel_fn, lr<span class="op">=</span>lr)</span>
<span id="cb130-12"><a href="#cb130-12" aria-hidden="true" tabindex="-1"></a>        qe, te <span class="op">=</span> qe_err(X,ws), te_err(X,ws)</span>
<span id="cb130-13"><a href="#cb130-13" aria-hidden="true" tabindex="-1"></a>        qe_errs.append(qe)</span>
<span id="cb130-14"><a href="#cb130-14" aria-hidden="true" tabindex="-1"></a>        te_errs.append(te)</span>
<span id="cb130-15"><a href="#cb130-15" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f'Epoch: </span><span class="sc">{</span>epoch<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss"> | QE: </span><span class="sc">{</span>qe_err(X,ws)<span class="sc">}</span><span class="ss">, TE: </span><span class="sc">{</span>te_err(X,ws)<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb130-16"><a href="#cb130-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ws, qe_errs, te_errs</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-149" class="cell">
<div class="sourceCode cell-code" id="cb131"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a>n_samples <span class="op">=</span> <span class="bu">len</span>(X)</span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a>grid_sz <span class="op">=</span> (n_nodes(n_samples),n_nodes(n_samples))</span>
<span id="cb131-3"><a href="#cb131-3" aria-hidden="true" tabindex="-1"></a>ws <span class="op">=</span> np.random.randn(<span class="op">*</span>grid_sz, X.shape[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb131-4"><a href="#cb131-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb131-5"><a href="#cb131-5" aria-hidden="true" tabindex="-1"></a>step_size<span class="op">=</span><span class="dv">100</span></span>
<span id="cb131-6"><a href="#cb131-6" aria-hidden="true" tabindex="-1"></a>lr_scheduler <span class="op">=</span> Scheduler(start_val<span class="op">=</span><span class="dv">1</span>, end_val<span class="op">=</span><span class="fl">0.01</span>, step_size<span class="op">=</span>step_size, </span>
<span id="cb131-7"><a href="#cb131-7" aria-hidden="true" tabindex="-1"></a>                        n_samples<span class="op">=</span><span class="bu">len</span>(X), n_epochs<span class="op">=</span>n_epochs)</span>
<span id="cb131-8"><a href="#cb131-8" aria-hidden="true" tabindex="-1"></a>sigma_scheduler <span class="op">=</span> Scheduler(start_val<span class="op">=</span><span class="fl">6.0</span>, end_val<span class="op">=</span><span class="fl">1.</span>, step_size<span class="op">=</span>step_size, </span>
<span id="cb131-9"><a href="#cb131-9" aria-hidden="true" tabindex="-1"></a>                          n_samples<span class="op">=</span><span class="bu">len</span>(X), n_epochs<span class="op">=</span>n_epochs)</span>
<span id="cb131-10"><a href="#cb131-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb131-11"><a href="#cb131-11" aria-hidden="true" tabindex="-1"></a>ws, qe_errs, te_errs <span class="op">=</span> fit(X, ws, lr_scheduler, sigma_scheduler, n_epochs<span class="op">=</span><span class="dv">20</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Epoch: 1 | QE: 0.7361545362516652, TE: 0.1
Epoch: 2 | QE: 0.5148950211961353, TE: 1.4
Epoch: 3 | QE: 0.4161479264406785, TE: 2.5
Epoch: 4 | QE: 0.3261032895452769, TE: 0.3
Epoch: 5 | QE: 0.4344722303659532, TE: 0.6
Epoch: 6 | QE: 0.4660129942532872, TE: 0.1
Epoch: 7 | QE: 0.3492315992581065, TE: 0.6
Epoch: 8 | QE: 0.30374238796782127, TE: 1.3
Epoch: 9 | QE: 0.31955520142421034, TE: 0.4
Epoch: 10 | QE: 0.26528420358326743, TE: 0.3
Epoch: 11 | QE: 0.23678200850531003, TE: 0.8
Epoch: 12 | QE: 0.21944164206845745, TE: 0.6
Epoch: 13 | QE: 0.20784349249994324, TE: 0.5
Epoch: 14 | QE: 0.20141528673718959, TE: 1.2
Epoch: 15 | QE: 0.18861138082733617, TE: 0.9
Epoch: 16 | QE: 0.17765457467386436, TE: 1.5
Epoch: 17 | QE: 0.17077969894350056, TE: 1.1
Epoch: 18 | QE: 0.16341102935415364, TE: 1.5
Epoch: 19 | QE: 0.15816356896585257, TE: 1.3
Epoch: 20 | QE: 0.154156360812519, TE: 0.7</code></pre>
</div>
</div>
<div id="cell-150" class="cell">
<div class="sourceCode cell-code" id="cb133"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a>plot_umatrix(ws)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="how-was-it-created_files/figure-html/cell-74-output-1.png" width="217" height="178" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p><strong>AI Prompt</strong></p>
<p>I am wondering how to best choose the initial and end learning rate and sigma. Is there any standard methodology other than grid search? Any thumb of rules I must be aware of?</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>AI Response</strong></p>
<p>Yes, there are some common guidelines for SOM hyperparameters:</p>
<ol type="1">
<li>Learning Rate (lr):
<ul>
<li>Start: Usually between 0.1 and 1.0</li>
<li>End: Small but non-zero (0.01 or even smaller)</li>
<li>Rule of thumb: Higher initial lr for larger datasets/maps</li>
</ul></li>
<li>Sigma (neighborhood radius):
<ul>
<li>Start: Usually max(grid_width, grid_height)/2</li>
<li>End: Should cover about one unit (0.5-1.0)</li>
<li>Rule of thumb: Larger initial sigma helps global ordering</li>
</ul></li>
<li>General principles:
<ul>
<li>Training has two phases:
<ol type="1">
<li>Ordering phase: High lr and sigma for global organization</li>
<li>Fine-tuning phase: Low lr and sigma for local adjustments</li>
</ol></li>
<li>Training length should be at least 500 times number of nodes</li>
</ul></li>
</ol>
<p>Would you like to try adjusting your parameters based on these guidelines?</p>
</div>
</div>
</section>
<section id="ii.8-revised-plan" class="level3">
<h3 class="anchored" data-anchor-id="ii.8-revised-plan">II.8 Revised plan</h3>
<p><strong>AI Prompt</strong></p>
<p>No that’s ok for now, thanks a lot! Now I think we need once more time to revise the plan as we are making very good progress and focus on the remaining steps. As a reminder, here below the previous plan: You make excellent points! Yes, we should revise the plan to better integrate visualization and metrics with the training loop, since they’re crucial for understanding how the SOM evolves. Here’s a suggested revision:</p>
<ol type="1">
<li>Core SOM Components (DONE)
<ul>
<li>✓ Initialize weight grid</li>
<li>✓ Distance metrics</li>
<li>✓ BMU function</li>
<li>✓ Neighborhood function</li>
<li>✓ Weight update rule</li>
</ul></li>
<li>Extended Training Components
<ul>
<li>Training loop structure - DONE</li>
<li>U-Matrix visualization (moved up from 4) - DONE</li>
<li>Basic quality metrics (moved up from 3) - DONE</li>
<li>Learning rate scheduler - DONE</li>
<li>Radius scheduler - DONE</li>
<li>Training progress visualization - DONE</li>
</ul></li>
<li>Additional Quality Metrics
<ul>
<li>Quantization error - DONE</li>
<li>Topographic error - DONE</li>
<li>Custom metrics interface</li>
</ul></li>
<li>Additional Visualizations
<ul>
<li>Component planes</li>
<li>Custom visualization options</li>
</ul></li>
<li>Refactoring
<ul>
<li>Class structure</li>
<li>Flexible interfaces</li>
<li>Documentation</li>
</ul></li>
</ol>
<p>I have further specified which steps were already completed! You evoked additional visualization techniques (on top of the u-matrix) and possible additional metrics. Last the refactoring and documentation phases remains highligh important as final steps. However there is one important aspects we have not addressed that we should address next which is the initialization of the SOM/weights. Now we are doing it randomly, I think we can use PCA also. I would be interested to understand it in further details and implement it.</p>
<p>Can you advise and propose an update plan? Important: Consider the numbering of each steps already used so that the new plan can be appended to it consistently.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>AI Response</strong></p>
<p>Yes, you’re right! The PCA initialization is an important addition. Here’s the updated plan, maintaining consistent numbering and adding the initialization as step 6 before refactoring:</p>
<ol start="3" type="I">
<li>Weights Initialization Methods</li>
</ol>
<ul>
<li>Random (current - DONE)</li>
<li>PCA-based initialization</li>
<li>Comparison of initialization impacts</li>
</ul>
<ol start="4" type="I">
<li>Additional Quality Metrics &amp; Visualization</li>
</ol>
<ul>
<li>Component planes</li>
<li>Additional custom metrics interface</li>
<li>Custom visualization options</li>
</ul>
<p>V. Refactoring &amp; Documentation - Class structure - Flexible interfaces - Comprehensive documentation - Usage examples</p>
<p>Would you like to start exploring the PCA initialization approach? I can explain how PCA can help initialize the SOM weights more effectively than random initialization.</p>
</div>
</div>
</section>
</section>
<section id="iii.-weights-initialization-methods" class="level2">
<h2 class="anchored" data-anchor-id="iii.-weights-initialization-methods">III. WEIGHTS INITIALIZATION METHODS</h2>
<p><strong>AI Prompt</strong></p>
<p>Can you explain what’s the idea of using PCA to initialize SOM weights?</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>AI Response</strong></p>
<p>The idea behind PCA initialization for SOM weights is quite clever:</p>
<ol type="1">
<li>Main concept:
<ul>
<li>Instead of random initialization, we want initial weights that already reflect the data’s structure</li>
<li>PCA finds the principal directions of variation in your data</li>
<li>We can use these directions to create a more informed initial grid</li>
</ul></li>
<li>The process typically works by:
<ul>
<li>Finding the two largest principal components of your data</li>
<li>Using these to create a linear interpolation grid</li>
<li>This grid becomes your initial weights</li>
</ul></li>
<li>Benefits:
<ul>
<li>Faster convergence (weights start closer to final configuration)</li>
<li>More stable training</li>
<li>Better preservation of data topology</li>
</ul></li>
</ol>
<p>Would you like me to explain more about how this works in practice, or would you prefer to start implementing it?</p>
</div>
</div>
<p><strong>AI Prompt</strong></p>
<p>Yes I know PCA but your statement “Using these to create a linear interpolation grid” is a bit unclear to me. Please further elaborate.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>AI Response</strong></p>
<p>Ah, let me clarify the linear interpolation part:</p>
<p>Let’s say we have a 4x4 SOM grid and our data is 3-dimensional. After PCA:</p>
<ol type="1">
<li>We get two principal components (PC1 and PC2)
<ul>
<li>These define a 2D plane where data varies most</li>
</ul></li>
<li>The “linear interpolation grid” means:
<ul>
<li>Along rows: We interpolate values from -1 to 1 using PC1 (4 points)</li>
<li>Along columns: We interpolate values from -1 to 1 using PC2 (4 points)</li>
<li>Each grid point becomes: (α<em>PC1 + β</em>PC2)</li>
<li>Where α and β are the interpolated values</li>
</ul></li>
</ol>
<p>So each weight vector is a linear combination of PC1 and PC2, creating a regular grid that spans the main directions of variation in your data.</p>
<p>Would you like to see this process with a small example using your dataset?</p>
</div>
</div>
<p><strong>AI Prompt</strong></p>
<p>Thanks it’s a bit clearer. Let me try to reformulate it, in the context of a highly dimensional dataset (which is the primary target of SOM), we take the two largest principal components (PCs) and generate the initial weights of the grid in the span of those two PCs.</p>
<p>I have two remarks: - in the situation where our input dataset is 2D, there would be no added value as we could have equally taken initial weights in the span of the initial basis (randomly) - don’t you think that would be also important to consider the eigen values (% of variance explained by each PCs) to generate those initial SOM weights? Do you see my point?</p>
<p>What do you think?</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>AI Response</strong></p>
<p>Excellent observations! Let me address both points:</p>
<ol type="1">
<li>2D data case:
<ul>
<li>✓ You’re absolutely right! PCA initialization would be less beneficial</li>
<li>The benefit really shows in higher dimensions where random initialization might miss important data structure</li>
</ul></li>
<li>Eigenvalues consideration:
<ul>
<li>✓ Very insightful point! Yes, the variance explained by each PC is important</li>
<li>We could use the eigenvalues to:
<ul>
<li>Scale the grid points according to the relative importance of each PC</li>
<li>Make the grid more stretched along PC1 if it explains much more variance than PC2</li>
<li>This would better reflect the actual data distribution</li>
</ul></li>
</ul></li>
</ol>
<p>Would you like to modify the initialization approach to incorporate the eigenvalues? We could scale the α and β coefficients by the square root of their respective eigenvalues to reflect the relative importance of each direction.</p>
</div>
</div>
<p><strong>AI Prompt</strong></p>
<p>Great!Let’s implement it but let me try first.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>AI Response</strong></p>
<p>Perfect! Go ahead and try implementing it yourself. If you get stuck or want to discuss your implementation, I’m here to help.</p>
<p>Remember you’ll need to: 1. Perform PCA on your data 2. Get the first two PCs and their eigenvalues 3. Create the interpolation grid with eigenvalue scaling</p>
<p>Let me know when you want to discuss your implementation or if you need any clarification!</p>
</div>
</div>
<p>To assess the added value of PCA initialization we should use a higher dimentionsal toy dataset. We choose the MNIST dataset for that purpose as provided by scikitlearn.</p>
<div id="cell-166" class="cell">
<div class="sourceCode cell-code" id="cb134"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.datasets <span class="im">import</span> load_digits</span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true" tabindex="-1"></a>X, y <span class="op">=</span> load_digits(return_X_y<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb134-4"><a href="#cb134-4" aria-hidden="true" tabindex="-1"></a>X.shape, y.shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>((1797, 64), (1797,))</code></pre>
</div>
</div>
<div id="cell-167" class="cell">
<div class="sourceCode cell-code" id="cb136"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Using column-wise centering to keep pixels correlation</span></span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a>X_norm <span class="op">=</span> (X <span class="op">-</span> np.mean(X, axis<span class="op">=-</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">True</span>))<span class="op">/</span>X.<span class="bu">max</span>()</span>
<span id="cb136-3"><a href="#cb136-3" aria-hidden="true" tabindex="-1"></a>X_norm[:<span class="dv">3</span>,:<span class="dv">3</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>array([[-0.28710938, -0.28710938,  0.02539062],
       [-0.30566406, -0.30566406, -0.30566406],
       [-0.3359375 , -0.3359375 , -0.3359375 ]])</code></pre>
</div>
</div>
<div id="cell-168" class="cell">
<div class="sourceCode cell-code" id="cb138"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">1</span>, <span class="dv">1</span>))  </span>
<span id="cb138-2"><a href="#cb138-2" aria-hidden="true" tabindex="-1"></a>plt.axis(<span class="st">'off'</span>)</span>
<span id="cb138-3"><a href="#cb138-3" aria-hidden="true" tabindex="-1"></a>plt.imshow(X_norm[<span class="dv">16</span>].reshape(<span class="dv">8</span>,<span class="dv">8</span>), cmap<span class="op">=</span><span class="st">'gray'</span>)</span>
<span id="cb138-4"><a href="#cb138-4" aria-hidden="true" tabindex="-1"></a>plt.tight_layout(pad<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb138-5"><a href="#cb138-5" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="how-was-it-created_files/figure-html/cell-77-output-1.png" width="120" height="120" class="figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="iii.1-random-initialization" class="level2">
<h2 class="anchored" data-anchor-id="iii.1-random-initialization">III.1 Random initialization</h2>
<div id="cell-170" class="cell">
<div class="sourceCode cell-code" id="cb139"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a><span class="co">#n_samples = len(X)</span></span>
<span id="cb139-2"><a href="#cb139-2" aria-hidden="true" tabindex="-1"></a><span class="co">#grid_sz = (n_nodes(n_samples),n_nodes(n_samples))</span></span>
<span id="cb139-3"><a href="#cb139-3" aria-hidden="true" tabindex="-1"></a>grid_sz <span class="op">=</span> (<span class="dv">20</span>,<span class="dv">20</span>)</span>
<span id="cb139-4"><a href="#cb139-4" aria-hidden="true" tabindex="-1"></a>ws <span class="op">=</span> np.random.randn(<span class="op">*</span>grid_sz, X.shape[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb139-5"><a href="#cb139-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-6"><a href="#cb139-6" aria-hidden="true" tabindex="-1"></a>step_size<span class="op">=</span><span class="dv">200</span></span>
<span id="cb139-7"><a href="#cb139-7" aria-hidden="true" tabindex="-1"></a>lr_scheduler <span class="op">=</span> Scheduler(start_val<span class="op">=</span><span class="dv">1</span>, end_val<span class="op">=</span><span class="fl">0.01</span>, step_size<span class="op">=</span>step_size, </span>
<span id="cb139-8"><a href="#cb139-8" aria-hidden="true" tabindex="-1"></a>                         n_samples<span class="op">=</span><span class="bu">len</span>(X), n_epochs<span class="op">=</span>n_epochs)</span>
<span id="cb139-9"><a href="#cb139-9" aria-hidden="true" tabindex="-1"></a>sigma_scheduler <span class="op">=</span> Scheduler(start_val<span class="op">=</span><span class="fl">10.0</span>, end_val<span class="op">=</span><span class="fl">1.</span>, step_size<span class="op">=</span>step_size, </span>
<span id="cb139-10"><a href="#cb139-10" aria-hidden="true" tabindex="-1"></a>                            n_samples<span class="op">=</span><span class="bu">len</span>(X), n_epochs<span class="op">=</span>n_epochs)</span>
<span id="cb139-11"><a href="#cb139-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-12"><a href="#cb139-12" aria-hidden="true" tabindex="-1"></a>ws, qe_errs, te_errs <span class="op">=</span> fit(X_norm, ws, lr_scheduler, sigma_scheduler, n_epochs<span class="op">=</span><span class="dv">20</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Epoch: 1 | QE: 2.0704569004526077, TE: 1.613800779076238
Epoch: 2 | QE: 1.9993114714766416, TE: 2.782415136338342
Epoch: 3 | QE: 1.861177046446639, TE: 0.8903728436282693
Epoch: 4 | QE: 1.9219833266979651, TE: 2.1702838063439067
Epoch: 5 | QE: 1.8149792250549173, TE: 1.947690595436839
Epoch: 6 | QE: 1.7232480060982525, TE: 0.5564830272676683
Epoch: 7 | QE: 1.6416867945969185, TE: 0.8347245409015025
Epoch: 8 | QE: 1.6012357873004686, TE: 0.8347245409015025
Epoch: 9 | QE: 1.525608040533907, TE: 0.38953811908736785
Epoch: 10 | QE: 1.4982022948153044, TE: 0.11129660545353366
Epoch: 11 | QE: 1.437747418705183, TE: 0.7790762381747357
Epoch: 12 | QE: 1.3905844080513237, TE: 0.6121313299944352
Epoch: 13 | QE: 1.3560227127148223, TE: 0.667779632721202
Epoch: 14 | QE: 1.3173744703746464, TE: 0.8347245409015025
Epoch: 15 | QE: 1.2798663316734378, TE: 0.7234279354479688
Epoch: 16 | QE: 1.2483547543469942, TE: 0.5008347245409015
Epoch: 17 | QE: 1.219034936826061, TE: 0.44518642181413465
Epoch: 18 | QE: 1.1926493832743006, TE: 0.44518642181413465
Epoch: 19 | QE: 1.1704315350038619, TE: 0.6121313299944352
Epoch: 20 | QE: 1.1514711948834122, TE: 0.8903728436282693</code></pre>
</div>
</div>
<div id="cell-171" class="cell">
<div class="sourceCode cell-code" id="cb141"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a>plot_umatrix(ws)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="how-was-it-created_files/figure-html/cell-79-output-1.png" width="217" height="178" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<section id="iii.2-pca-initialization" class="level3">
<h3 class="anchored" data-anchor-id="iii.2-pca-initialization">III.2 PCA initialization</h3>
<div id="cell-173" class="cell">
<div class="sourceCode cell-code" id="cb142"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.decomposition <span class="im">import</span> PCA</span>
<span id="cb142-2"><a href="#cb142-2" aria-hidden="true" tabindex="-1"></a>pca <span class="op">=</span> PCA(n_components<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb142-3"><a href="#cb142-3" aria-hidden="true" tabindex="-1"></a>pca.fit(X_norm)</span>
<span id="cb142-4"><a href="#cb142-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(pca.explained_variance_ratio_)</span>
<span id="cb142-5"><a href="#cb142-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(pca.singular_values_)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[0.15122797 0.13826949]
[35.43643386 33.88419201]</code></pre>
</div>
</div>
<div id="cell-174" class="cell">
<div class="sourceCode cell-code" id="cb144"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a>pca.components_.shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>(2, 64)</code></pre>
</div>
</div>
<div id="cell-175" class="cell">
<div class="sourceCode cell-code" id="cb146"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a>np.linspace(<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>,num<span class="op">=</span><span class="dv">10</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>array([-1.        , -0.77777778, -0.55555556, -0.33333333, -0.11111111,
        0.11111111,  0.33333333,  0.55555556,  0.77777778,  1.        ])</code></pre>
</div>
</div>
<div id="cell-176" class="cell">
<div class="sourceCode cell-code" id="cb148"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb148-1"><a href="#cb148-1" aria-hidden="true" tabindex="-1"></a><span class="co"># -1*e1*v1 + -1*e2*v2</span></span>
<span id="cb148-2"><a href="#cb148-2" aria-hidden="true" tabindex="-1"></a><span class="co"># -0.9*e1*v1 + -0.9*e2*v2</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>AI Prompt</strong></p>
<p>Once I have the 2 highest eigen values and vectors, how do I create a <code>nxn</code> matrix to be used as SOM based on this?</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>AI Response</strong></p>
<p>For a n×n SOM grid, here’s how to create the PCA-initialized weights:</p>
<ol type="1">
<li>Create two sets of coefficients:</li>
</ol>
<div class="sourceCode" id="cb149"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a>alpha <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, n)  <span class="co"># for PC1</span></span>
<span id="cb149-2"><a href="#cb149-2" aria-hidden="true" tabindex="-1"></a>beta <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, n)   <span class="co"># for PC2</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol type="1">
<li>Scale them by square root of eigenvalues:</li>
</ol>
<div class="sourceCode" id="cb150"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a>alpha <span class="op">*=</span> np.sqrt(pca.explained_variance_[<span class="dv">0</span>])</span>
<span id="cb150-2"><a href="#cb150-2" aria-hidden="true" tabindex="-1"></a>beta <span class="op">*=</span> np.sqrt(pca.explained_variance_[<span class="dv">1</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol type="1">
<li>Create the grid using outer products:</li>
</ol>
<div class="sourceCode" id="cb151"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create meshgrid</span></span>
<span id="cb151-2"><a href="#cb151-2" aria-hidden="true" tabindex="-1"></a>alpha_grid, beta_grid <span class="op">=</span> np.meshgrid(alpha, beta)</span>
<span id="cb151-3"><a href="#cb151-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb151-4"><a href="#cb151-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize weights array</span></span>
<span id="cb151-5"><a href="#cb151-5" aria-hidden="true" tabindex="-1"></a>weights <span class="op">=</span> np.zeros((n, n, X.shape[<span class="dv">1</span>]))  <span class="co"># shape: (n, n, 64) for MNIST</span></span>
<span id="cb151-6"><a href="#cb151-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb151-7"><a href="#cb151-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Each weight is a linear combination of PC1 and PC2</span></span>
<span id="cb151-8"><a href="#cb151-8" aria-hidden="true" tabindex="-1"></a>weights <span class="op">=</span> (alpha_grid[..., np.newaxis] <span class="op">*</span> pca.components_[<span class="dv">0</span>] <span class="op">+</span> </span>
<span id="cb151-9"><a href="#cb151-9" aria-hidden="true" tabindex="-1"></a>          beta_grid[..., np.newaxis] <span class="op">*</span> pca.components_[<span class="dv">1</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Would you like to try implementing this approach?</p>
</div>
</div>
<div id="cell-179" class="cell">
<div class="sourceCode cell-code" id="cb152"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true" tabindex="-1"></a>grid_sz <span class="op">=</span> (<span class="dv">20</span>,<span class="dv">20</span>)</span>
<span id="cb152-2"><a href="#cb152-2" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> grid_sz[<span class="dv">0</span>]</span>
<span id="cb152-3"><a href="#cb152-3" aria-hidden="true" tabindex="-1"></a>alpha <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, n)  <span class="co"># for PC1</span></span>
<span id="cb152-4"><a href="#cb152-4" aria-hidden="true" tabindex="-1"></a>beta <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, n)   <span class="co"># for PC2</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-180" class="cell">
<div class="sourceCode cell-code" id="cb153"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a>alpha <span class="op">*=</span> np.sqrt(pca.explained_variance_[<span class="dv">0</span>])</span>
<span id="cb153-2"><a href="#cb153-2" aria-hidden="true" tabindex="-1"></a>beta <span class="op">*=</span> np.sqrt(pca.explained_variance_[<span class="dv">1</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-181" class="cell">
<div class="sourceCode cell-code" id="cb154"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true" tabindex="-1"></a>alpha_grid, beta_grid <span class="op">=</span> np.meshgrid(alpha, beta)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-182" class="cell">
<div class="sourceCode cell-code" id="cb155"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a>ws <span class="op">=</span> np.zeros((n, n, X.shape[<span class="dv">1</span>]))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-183" class="cell">
<div class="sourceCode cell-code" id="cb156"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true" tabindex="-1"></a>ws <span class="op">=</span> (alpha_grid[..., np.newaxis] <span class="op">*</span> pca.components_[<span class="dv">0</span>] <span class="op">+</span> </span>
<span id="cb156-2"><a href="#cb156-2" aria-hidden="true" tabindex="-1"></a>          beta_grid[..., np.newaxis] <span class="op">*</span> pca.components_[<span class="dv">1</span>])</span>
<span id="cb156-3"><a href="#cb156-3" aria-hidden="true" tabindex="-1"></a>ws.shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>(20, 20, 64)</code></pre>
</div>
</div>
<div id="cell-184" class="cell">
<div class="sourceCode cell-code" id="cb158"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a>step_size<span class="op">=</span><span class="dv">200</span></span>
<span id="cb158-2"><a href="#cb158-2" aria-hidden="true" tabindex="-1"></a>lr_scheduler <span class="op">=</span> Scheduler(start_val<span class="op">=</span><span class="dv">1</span>, end_val<span class="op">=</span><span class="fl">0.01</span>, step_size<span class="op">=</span>step_size, </span>
<span id="cb158-3"><a href="#cb158-3" aria-hidden="true" tabindex="-1"></a>                         n_samples<span class="op">=</span><span class="bu">len</span>(X), n_epochs<span class="op">=</span>n_epochs)</span>
<span id="cb158-4"><a href="#cb158-4" aria-hidden="true" tabindex="-1"></a>sigma_scheduler <span class="op">=</span> Scheduler(start_val<span class="op">=</span><span class="fl">10.0</span>, end_val<span class="op">=</span><span class="fl">1.</span>, step_size<span class="op">=</span>step_size, </span>
<span id="cb158-5"><a href="#cb158-5" aria-hidden="true" tabindex="-1"></a>                            n_samples<span class="op">=</span><span class="bu">len</span>(X), n_epochs<span class="op">=</span>n_epochs)</span>
<span id="cb158-6"><a href="#cb158-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb158-7"><a href="#cb158-7" aria-hidden="true" tabindex="-1"></a>ws, qe_errs, te_errs <span class="op">=</span> fit(X_norm, ws, lr_scheduler, sigma_scheduler, n_epochs<span class="op">=</span><span class="dv">20</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Epoch: 1 | QE: 2.021117062983796, TE: 2.949360044518642
Epoch: 2 | QE: 2.0374532407086186, TE: 3.728436282693378
Epoch: 3 | QE: 1.9381056000802876, TE: 1.1686143572621035
Epoch: 4 | QE: 1.8750135481900163, TE: 3.394546466332777
Epoch: 5 | QE: 1.7731177749486253, TE: 0.9460211463550362
Epoch: 6 | QE: 1.7381528690875534, TE: 1.1129660545353366
Epoch: 7 | QE: 1.6576526895942232, TE: 1.335559265442404
Epoch: 8 | QE: 1.585401407283374, TE: 1.279910962715637
Epoch: 9 | QE: 1.564939121993558, TE: 0.9460211463550362
Epoch: 10 | QE: 1.4887308931209031, TE: 0.8347245409015025
Epoch: 11 | QE: 1.4567525145876061, TE: 0.8347245409015025
Epoch: 12 | QE: 1.3981773691503705, TE: 0.667779632721202
Epoch: 13 | QE: 1.3556213938081516, TE: 0.667779632721202
Epoch: 14 | QE: 1.317842103259422, TE: 0.7790762381747357
Epoch: 15 | QE: 1.2812507568473976, TE: 0.5008347245409015
Epoch: 16 | QE: 1.2470507719706745, TE: 0.5564830272676683
Epoch: 17 | QE: 1.2189855689098217, TE: 0.5564830272676683
Epoch: 18 | QE: 1.1935169201963478, TE: 0.5008347245409015
Epoch: 19 | QE: 1.1719132431346526, TE: 0.6121313299944352
Epoch: 20 | QE: 1.1539758415894774, TE: 0.8347245409015025</code></pre>
</div>
</div>
<div id="cell-185" class="cell">
<div class="sourceCode cell-code" id="cb160"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a>plot_umatrix(ws)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="how-was-it-created_files/figure-html/cell-90-output-1.png" width="217" height="178" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p><strong>AI Prompt</strong></p>
<p>The effect of PCA initialization is not probative above. How could I see the added value?</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>AI Response</strong></p>
<p>To better demonstrate the value of PCA initialization, we could:</p>
<ol type="1">
<li>Compare convergence speed:
<ul>
<li>Run both initializations multiple times</li>
<li>Plot learning curves (QE vs epochs) on the same graph</li>
<li>Start with fewer epochs to see early convergence</li>
</ul></li>
<li>Use a more complex dataset:
<ul>
<li>MNIST digits at higher resolution</li>
<li>Or a dataset with more pronounced principal components</li>
<li>Currently we’re using 8x8 digits which might be too simple</li>
</ul></li>
<li>Visualize initial state:
<ul>
<li>Show U-Matrix right after initialization (before training)</li>
<li>Compare random vs PCA initialization structures</li>
</ul></li>
<li>Adjust hyperparameters:
<ul>
<li>Different learning rates</li>
<li>Different grid sizes</li>
<li>Different sigma values</li>
</ul></li>
</ol>
<p>Which approach would you like to try first to better demonstrate the difference between random and PCA initialization?</p>
</div>
</div>
<p><strong>AI Prompt</strong></p>
<p>Thanks, very useful! That’s fine for now I will perform this thorough assessment later.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>AI Response</strong></p>
<p>Alright! We’ve covered PCA initialization and have some good ideas for evaluating its effectiveness later.</p>
<p>Would you like to move on to the next part of our plan? We could look at: 1. Component planes visualization 2. Additional quality metrics 3. Start the refactoring phase</p>
<p>Which would you prefer to tackle next?</p>
</div>
</div>
</section>
</section>
<section id="iv.-additional-visualizations" class="level2">
<h2 class="anchored" data-anchor-id="iv.-additional-visualizations">IV. ADDITIONAL VISUALIZATIONS</h2>
<p><strong>AI Prompt</strong></p>
<p>Explain me the concept of “Component planes visualization” in the contexte of the MNIST dataset for instance.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>AI Response</strong></p>
<p>In the context of MNIST, component planes visualization is particularly interesting:</p>
<ol type="1">
<li>Basic concept:
<ul>
<li>Each weight vector (node) has 64 components (8x8 pixels)</li>
<li>A component plane shows how ONE of these 64 components varies across the SOM grid</li>
<li>We get 64 different “heatmaps”, one for each pixel position</li>
</ul></li>
<li>For MNIST specifically:
<ul>
<li>Each component plane shows how a specific pixel varies across the map</li>
<li>Bright areas = high pixel values in that position</li>
<li>Dark areas = low pixel values in that position</li>
<li>This reveals which regions of the SOM activate specific parts of the digits</li>
</ul></li>
<li>Interpretation:
<ul>
<li>Similar patterns across component planes suggest correlated pixels</li>
<li>Some planes might show clear structures (e.g., strong activation in middle pixels for digit “1”)</li>
<li>Helps understand how the SOM has organized digit features</li>
</ul></li>
</ol>
<p>Would you like to visualize some component planes for our trained MNIST SOM to see this in practice?</p>
</div>
</div>
<p><strong>AI Prompt</strong></p>
<p>Ok I see, I will implement it later, let’s focus on the refactoring and the documentation now.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>AI Response</strong></p>
<p>Sure! For refactoring, we should create a well-structured class that encapsulates all the functionality we’ve built. Here’s what we could consider:</p>
<ol type="1">
<li>Core SOM Class structure:
<ul>
<li>Initialization (random/PCA)</li>
<li>Training methods</li>
<li>Visualization methods</li>
<li>Quality metrics</li>
<li>Flexible interfaces for schedulers</li>
</ul></li>
<li>Documentation needs:
<ul>
<li>Clear docstrings</li>
<li>Usage examples</li>
<li>Parameter descriptions</li>
<li>References to literature</li>
</ul></li>
</ol>
<p>Would you like to start with: 1. Designing the class interface 2. Writing the documentation structure 3. Organizing the methods we’ve created</p>
<p>Which aspect would you prefer to tackle first?</p>
</div>
</div>
</section>
<section id="v.-refactoring" class="level2">
<h2 class="anchored" data-anchor-id="v.-refactoring">V. REFACTORING</h2>
<p><strong>AI Prompt</strong></p>
<p>Please design a class interface embedding all components implemented above. Make sure to: - use nbdev-like documentation and docstrings - use fastai coding style</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>I’ll design a class interface following nbdev and fastai style. Let’s start with the core class structure:</p>
<div class="sourceCode" id="cb161"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SOM:</span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, grid_sz:<span class="bu">tuple</span>, <span class="co"># Size of the SOM grid (rows, cols)</span></span>
<span id="cb161-3"><a href="#cb161-3" aria-hidden="true" tabindex="-1"></a>                 input_dim:<span class="bu">int</span>,        <span class="co"># Dimension of input data</span></span>
<span id="cb161-4"><a href="#cb161-4" aria-hidden="true" tabindex="-1"></a>                 init:<span class="bu">str</span><span class="op">=</span><span class="st">'random'</span>,    <span class="co"># Initialization method: 'random' or 'pca'</span></span>
<span id="cb161-5"><a href="#cb161-5" aria-hidden="true" tabindex="-1"></a>                 dist_fn<span class="op">=</span>np.linalg.norm <span class="co"># Distance metric function</span></span>
<span id="cb161-6"><a href="#cb161-6" aria-hidden="true" tabindex="-1"></a>                ):</span>
<span id="cb161-7"><a href="#cb161-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">"Initialize a Self-Organizing Map with given grid size and input dimension"</span></span>
<span id="cb161-8"><a href="#cb161-8" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb161-9"><a href="#cb161-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> fit(<span class="va">self</span>, X:np.ndarray,           <span class="co"># Training data</span></span>
<span id="cb161-10"><a href="#cb161-10" aria-hidden="true" tabindex="-1"></a>            n_epochs:<span class="bu">int</span><span class="op">=</span><span class="dv">20</span>,              <span class="co"># Number of training epochs</span></span>
<span id="cb161-11"><a href="#cb161-11" aria-hidden="true" tabindex="-1"></a>            lr_scheduler:Scheduler<span class="op">=</span><span class="va">None</span>,   <span class="co"># Learning rate scheduler</span></span>
<span id="cb161-12"><a href="#cb161-12" aria-hidden="true" tabindex="-1"></a>            sigma_scheduler:Scheduler<span class="op">=</span><span class="va">None</span>, <span class="co"># Neighborhood radius scheduler</span></span>
<span id="cb161-13"><a href="#cb161-13" aria-hidden="true" tabindex="-1"></a>            shuffle:<span class="bu">bool</span><span class="op">=</span><span class="va">True</span>,             <span class="co"># Shuffle data each epoch</span></span>
<span id="cb161-14"><a href="#cb161-14" aria-hidden="true" tabindex="-1"></a>            verbose:<span class="bu">bool</span><span class="op">=</span><span class="va">True</span>              <span class="co"># Print training progress</span></span>
<span id="cb161-15"><a href="#cb161-15" aria-hidden="true" tabindex="-1"></a>           )<span class="op">-&gt;</span><span class="bu">tuple</span>:                       <span class="co"># Returns (weights, qe_errors, te_errors)</span></span>
<span id="cb161-16"><a href="#cb161-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">"Train the SOM on input data X"</span></span>
<span id="cb161-17"><a href="#cb161-17" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb161-18"><a href="#cb161-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> transform(<span class="va">self</span>, X:np.ndarray <span class="co"># Input data to transform</span></span>
<span id="cb161-19"><a href="#cb161-19" aria-hidden="true" tabindex="-1"></a>                )<span class="op">-&gt;</span>np.ndarray:       <span class="co"># Returns BMU coordinates for each input</span></span>
<span id="cb161-20"><a href="#cb161-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">"Find Best Matching Unit (BMU) for each input vector"</span></span>
<span id="cb161-21"><a href="#cb161-21" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb161-22"><a href="#cb161-22" aria-hidden="true" tabindex="-1"></a>    <span class="at">@property</span></span>
<span id="cb161-23"><a href="#cb161-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> umatrix(<span class="va">self</span>)<span class="op">-&gt;</span>np.ndarray:  <span class="co"># Returns U-Matrix of current weights</span></span>
<span id="cb161-24"><a href="#cb161-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">"Calculate and return the U-Matrix"</span></span>
<span id="cb161-25"><a href="#cb161-25" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb161-26"><a href="#cb161-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> quantization_error(<span class="va">self</span>, X:np.ndarray <span class="co"># Input data</span></span>
<span id="cb161-27"><a href="#cb161-27" aria-hidden="true" tabindex="-1"></a>                         )<span class="op">-&gt;</span><span class="bu">float</span>:            <span class="co"># Returns QE value</span></span>
<span id="cb161-28"><a href="#cb161-28" aria-hidden="true" tabindex="-1"></a>        <span class="co">"Calculate quantization error for input data"</span></span>
<span id="cb161-29"><a href="#cb161-29" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb161-30"><a href="#cb161-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> topographic_error(<span class="va">self</span>, X:np.ndarray <span class="co"># Input data</span></span>
<span id="cb161-31"><a href="#cb161-31" aria-hidden="true" tabindex="-1"></a>                        )<span class="op">-&gt;</span><span class="bu">float</span>:            <span class="co"># Returns TE value</span></span>
<span id="cb161-32"><a href="#cb161-32" aria-hidden="true" tabindex="-1"></a>        <span class="co">"Calculate topographic error for input data"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Would you like me to: 1. Add more methods 2. Elaborate on any particular method 3. Add more documentation details 4. Show how the existing functions would fit into this structure</p>
<p>What would be most helpful?</p>
</div>
</div>
<p><strong>AI Prompt</strong></p>
<p>The interface looks fine, please feed it with the implementations</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>I’ll help you implement the class step by step. Let’s start with the core structure and basic methods:</p>
<div class="sourceCode" id="cb162"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SOM:</span>
<span id="cb162-2"><a href="#cb162-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, grid_sz:<span class="bu">tuple</span>, input_dim:<span class="bu">int</span>, init:<span class="bu">str</span><span class="op">=</span><span class="st">'random'</span>, dist_fn<span class="op">=</span>np.linalg.norm):</span>
<span id="cb162-3"><a href="#cb162-3" aria-hidden="true" tabindex="-1"></a>        <span class="co">"Initialize a Self-Organizing Map with given grid size and input dimension"</span></span>
<span id="cb162-4"><a href="#cb162-4" aria-hidden="true" tabindex="-1"></a>        store_attr()</span>
<span id="cb162-5"><a href="#cb162-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.weights <span class="op">=</span> <span class="va">self</span>._initialize_weights(init)</span>
<span id="cb162-6"><a href="#cb162-6" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb162-7"><a href="#cb162-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _initialize_weights(<span class="va">self</span>, method:<span class="bu">str</span>)<span class="op">-&gt;</span>np.ndarray:</span>
<span id="cb162-8"><a href="#cb162-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">"Initialize weights using either random or PCA initialization"</span></span>
<span id="cb162-9"><a href="#cb162-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> method <span class="op">==</span> <span class="st">'random'</span>:</span>
<span id="cb162-10"><a href="#cb162-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> np.random.randn(<span class="op">*</span><span class="va">self</span>.grid_sz, <span class="va">self</span>.input_dim)</span>
<span id="cb162-11"><a href="#cb162-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> method <span class="op">==</span> <span class="st">'pca'</span>:</span>
<span id="cb162-12"><a href="#cb162-12" aria-hidden="true" tabindex="-1"></a>            <span class="co"># We'll implement PCA initialization</span></span>
<span id="cb162-13"><a href="#cb162-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">NotImplementedError</span>(<span class="st">"PCA initialization to be implemented"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Would you like me to continue with implementing more methods? We can do this incrementally, testing each part as we go. Which method would you like to implement next?</p>
<ol type="1">
<li>PCA initialization</li>
<li>Core training loop (fit)</li>
<li>Transform method</li>
<li>Error metrics</li>
</ol>
<p>Let me know which you’d prefer to tackle first!</p>
</div>
</div>
<p><strong>AI Prompt</strong></p>
<p>Next implement, PCA initialization.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>I’ll add the PCA initialization to our SOM class. We’ll need to modify the <code>_initialize_weights</code> method and add a helper method for PCA:</p>
<div class="sourceCode" id="cb163"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.decomposition <span class="im">import</span> PCA</span>
<span id="cb163-2"><a href="#cb163-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb163-3"><a href="#cb163-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SOM:</span>
<span id="cb163-4"><a href="#cb163-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, grid_sz:<span class="bu">tuple</span>, input_dim:<span class="bu">int</span>, init:<span class="bu">str</span><span class="op">=</span><span class="st">'random'</span>, dist_fn<span class="op">=</span>np.linalg.norm):</span>
<span id="cb163-5"><a href="#cb163-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">"Initialize a Self-Organizing Map with given grid size and input dimension"</span></span>
<span id="cb163-6"><a href="#cb163-6" aria-hidden="true" tabindex="-1"></a>        store_attr()</span>
<span id="cb163-7"><a href="#cb163-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.weights <span class="op">=</span> <span class="va">None</span>  <span class="co"># Will be initialized when fitting</span></span>
<span id="cb163-8"><a href="#cb163-8" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb163-9"><a href="#cb163-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _initialize_weights_pca(<span class="va">self</span>, X:np.ndarray)<span class="op">-&gt;</span>np.ndarray:</span>
<span id="cb163-10"><a href="#cb163-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">"Initialize weights using PCA of the input data"</span></span>
<span id="cb163-11"><a href="#cb163-11" aria-hidden="true" tabindex="-1"></a>        pca <span class="op">=</span> PCA(n_components<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb163-12"><a href="#cb163-12" aria-hidden="true" tabindex="-1"></a>        pca.fit(X)</span>
<span id="cb163-13"><a href="#cb163-13" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb163-14"><a href="#cb163-14" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Create grid coordinates and scale by eigenvalues</span></span>
<span id="cb163-15"><a href="#cb163-15" aria-hidden="true" tabindex="-1"></a>        n <span class="op">=</span> <span class="va">self</span>.grid_sz[<span class="dv">0</span>]</span>
<span id="cb163-16"><a href="#cb163-16" aria-hidden="true" tabindex="-1"></a>        alpha <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, n) <span class="op">*</span> np.sqrt(pca.explained_variance_[<span class="dv">0</span>])</span>
<span id="cb163-17"><a href="#cb163-17" aria-hidden="true" tabindex="-1"></a>        beta <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, n) <span class="op">*</span> np.sqrt(pca.explained_variance_[<span class="dv">1</span>])</span>
<span id="cb163-18"><a href="#cb163-18" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb163-19"><a href="#cb163-19" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Create the grid</span></span>
<span id="cb163-20"><a href="#cb163-20" aria-hidden="true" tabindex="-1"></a>        alpha_grid, beta_grid <span class="op">=</span> np.meshgrid(alpha, beta)</span>
<span id="cb163-21"><a href="#cb163-21" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb163-22"><a href="#cb163-22" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Initialize weights as linear combination of first two PCs</span></span>
<span id="cb163-23"><a href="#cb163-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (alpha_grid[..., np.newaxis] <span class="op">*</span> pca.components_[<span class="dv">0</span>] <span class="op">+</span> </span>
<span id="cb163-24"><a href="#cb163-24" aria-hidden="true" tabindex="-1"></a>                beta_grid[..., np.newaxis] <span class="op">*</span> pca.components_[<span class="dv">1</span>])</span>
<span id="cb163-25"><a href="#cb163-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb163-26"><a href="#cb163-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _initialize_weights(<span class="va">self</span>, X:np.ndarray<span class="op">=</span><span class="va">None</span>, method:<span class="bu">str</span><span class="op">=</span><span class="st">'random'</span>)<span class="op">-&gt;</span>np.ndarray:</span>
<span id="cb163-27"><a href="#cb163-27" aria-hidden="true" tabindex="-1"></a>        <span class="co">"Initialize weights using either random or PCA initialization"</span></span>
<span id="cb163-28"><a href="#cb163-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> method <span class="op">==</span> <span class="st">'random'</span>:</span>
<span id="cb163-29"><a href="#cb163-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> np.random.randn(<span class="op">*</span><span class="va">self</span>.grid_sz, <span class="va">self</span>.input_dim)</span>
<span id="cb163-30"><a href="#cb163-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> method <span class="op">==</span> <span class="st">'pca'</span>:</span>
<span id="cb163-31"><a href="#cb163-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> X <span class="kw">is</span> <span class="va">None</span>: </span>
<span id="cb163-32"><a href="#cb163-32" aria-hidden="true" tabindex="-1"></a>                <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Data matrix X required for PCA initialization"</span>)</span>
<span id="cb163-33"><a href="#cb163-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">self</span>._initialize_weights_pca(X)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Note that we’ve modified the initialization to: 1. Accept the input data X when needed for PCA 2. Move PCA logic to a separate method 3. Make weights initialization defer until we have data</p>
<p>Would you like to implement the next component? We could tackle: 1. Core training loop (fit) 2. Transform method 3. Error metrics</p>
<p>Which would you prefer?</p>
</div>
</div>
<p><strong>AI Prompt</strong></p>
<p>Implement the core training loop</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>I’ll implement the core training loop (fit method) and its supporting functions. We’ll need to include the neighborhood and update logic we developed earlier:</p>
<div class="sourceCode" id="cb164"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SOM:</span>
<span id="cb164-2"><a href="#cb164-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ... (previous methods remain the same)</span></span>
<span id="cb164-3"><a href="#cb164-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb164-4"><a href="#cb164-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _find_bmu(<span class="va">self</span>, x:np.ndarray)<span class="op">-&gt;</span><span class="bu">tuple</span>:</span>
<span id="cb164-5"><a href="#cb164-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">"Find coordinates of Best Matching Unit for input x"</span></span>
<span id="cb164-6"><a href="#cb164-6" aria-hidden="true" tabindex="-1"></a>        distances <span class="op">=</span> <span class="va">self</span>.dist_fn(x, <span class="va">self</span>.weights)</span>
<span id="cb164-7"><a href="#cb164-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.unravel_index(np.argmin(distances), <span class="va">self</span>.grid_sz)</span>
<span id="cb164-8"><a href="#cb164-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb164-9"><a href="#cb164-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _grid_distances(<span class="va">self</span>, bmu_pos:<span class="bu">tuple</span>)<span class="op">-&gt;</span>np.ndarray:</span>
<span id="cb164-10"><a href="#cb164-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">"Calculate grid distances from BMU position"</span></span>
<span id="cb164-11"><a href="#cb164-11" aria-hidden="true" tabindex="-1"></a>        rows_idx, cols_idx <span class="op">=</span> np.ogrid[<span class="dv">0</span>:<span class="va">self</span>.grid_sz[<span class="dv">0</span>], <span class="dv">0</span>:<span class="va">self</span>.grid_sz[<span class="dv">1</span>]]</span>
<span id="cb164-12"><a href="#cb164-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (bmu_pos[<span class="dv">0</span>] <span class="op">-</span> rows_idx)<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> (bmu_pos[<span class="dv">1</span>] <span class="op">-</span> cols_idx)<span class="op">**</span><span class="dv">2</span></span>
<span id="cb164-13"><a href="#cb164-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb164-14"><a href="#cb164-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _neighborhood_function(<span class="va">self</span>, grid_dist:np.ndarray, sigma:<span class="bu">float</span>)<span class="op">-&gt;</span>np.ndarray:</span>
<span id="cb164-15"><a href="#cb164-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">"Calculate neighborhood function values"</span></span>
<span id="cb164-16"><a href="#cb164-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.exp(<span class="op">-</span>grid_dist<span class="op">/</span>(<span class="dv">2</span><span class="op">*</span>sigma<span class="op">**</span><span class="dv">2</span>))</span>
<span id="cb164-17"><a href="#cb164-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb164-18"><a href="#cb164-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _update_weights(<span class="va">self</span>, x:np.ndarray, learning_rate:<span class="bu">float</span>, sigma:<span class="bu">float</span>):</span>
<span id="cb164-19"><a href="#cb164-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">"Update weights for a single input vector"</span></span>
<span id="cb164-20"><a href="#cb164-20" aria-hidden="true" tabindex="-1"></a>        bmu_pos <span class="op">=</span> <span class="va">self</span>._find_bmu(x)</span>
<span id="cb164-21"><a href="#cb164-21" aria-hidden="true" tabindex="-1"></a>        grid_dist <span class="op">=</span> <span class="va">self</span>._grid_distances(bmu_pos)</span>
<span id="cb164-22"><a href="#cb164-22" aria-hidden="true" tabindex="-1"></a>        neighborhood <span class="op">=</span> <span class="va">self</span>._neighborhood_function(grid_dist, sigma)</span>
<span id="cb164-23"><a href="#cb164-23" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.weights <span class="op">+=</span> learning_rate <span class="op">*</span> neighborhood[..., np.newaxis] <span class="op">*</span> (x <span class="op">-</span> <span class="va">self</span>.weights)</span>
<span id="cb164-24"><a href="#cb164-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb164-25"><a href="#cb164-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> fit(<span class="va">self</span>, X:np.ndarray, n_epochs:<span class="bu">int</span><span class="op">=</span><span class="dv">20</span>, </span>
<span id="cb164-26"><a href="#cb164-26" aria-hidden="true" tabindex="-1"></a>            lr_scheduler:Scheduler<span class="op">=</span><span class="va">None</span>, sigma_scheduler:Scheduler<span class="op">=</span><span class="va">None</span>,</span>
<span id="cb164-27"><a href="#cb164-27" aria-hidden="true" tabindex="-1"></a>            shuffle:<span class="bu">bool</span><span class="op">=</span><span class="va">True</span>, verbose:<span class="bu">bool</span><span class="op">=</span><span class="va">True</span>)<span class="op">-&gt;</span><span class="bu">tuple</span>:</span>
<span id="cb164-28"><a href="#cb164-28" aria-hidden="true" tabindex="-1"></a>        <span class="co">"Train the SOM on input data X"</span></span>
<span id="cb164-29"><a href="#cb164-29" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Initialize weights if not already done</span></span>
<span id="cb164-30"><a href="#cb164-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.weights <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb164-31"><a href="#cb164-31" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.weights <span class="op">=</span> <span class="va">self</span>._initialize_weights(X, <span class="va">self</span>.init)</span>
<span id="cb164-32"><a href="#cb164-32" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb164-33"><a href="#cb164-33" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Setup default schedulers if none provided</span></span>
<span id="cb164-34"><a href="#cb164-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> lr_scheduler <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb164-35"><a href="#cb164-35" aria-hidden="true" tabindex="-1"></a>            lr_scheduler <span class="op">=</span> Scheduler(<span class="fl">1.0</span>, <span class="fl">0.01</span>, <span class="dv">100</span>, <span class="bu">len</span>(X), n_epochs)</span>
<span id="cb164-36"><a href="#cb164-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> sigma_scheduler <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb164-37"><a href="#cb164-37" aria-hidden="true" tabindex="-1"></a>            sigma_scheduler <span class="op">=</span> Scheduler(<span class="bu">max</span>(<span class="va">self</span>.grid_sz)<span class="op">/</span><span class="dv">2</span>, <span class="fl">1.0</span>, <span class="dv">100</span>, <span class="bu">len</span>(X), n_epochs)</span>
<span id="cb164-38"><a href="#cb164-38" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb164-39"><a href="#cb164-39" aria-hidden="true" tabindex="-1"></a>        qe_errors, te_errors <span class="op">=</span> [], []</span>
<span id="cb164-40"><a href="#cb164-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> epoch <span class="kw">in</span> <span class="bu">range</span>(n_epochs):</span>
<span id="cb164-41"><a href="#cb164-41" aria-hidden="true" tabindex="-1"></a>            X_ <span class="op">=</span> np.random.permutation(X) <span class="cf">if</span> shuffle <span class="cf">else</span> X.copy()</span>
<span id="cb164-42"><a href="#cb164-42" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb164-43"><a href="#cb164-43" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Train on each input vector</span></span>
<span id="cb164-44"><a href="#cb164-44" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> i, x <span class="kw">in</span> <span class="bu">enumerate</span>(X_):</span>
<span id="cb164-45"><a href="#cb164-45" aria-hidden="true" tabindex="-1"></a>                total_samples <span class="op">=</span> epoch <span class="op">*</span> <span class="bu">len</span>(X) <span class="op">+</span> i</span>
<span id="cb164-46"><a href="#cb164-46" aria-hidden="true" tabindex="-1"></a>                lr <span class="op">=</span> lr_scheduler.step(total_samples)</span>
<span id="cb164-47"><a href="#cb164-47" aria-hidden="true" tabindex="-1"></a>                sigma <span class="op">=</span> sigma_scheduler.step(total_samples)</span>
<span id="cb164-48"><a href="#cb164-48" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>._update_weights(x, lr, sigma)</span>
<span id="cb164-49"><a href="#cb164-49" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb164-50"><a href="#cb164-50" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Calculate errors</span></span>
<span id="cb164-51"><a href="#cb164-51" aria-hidden="true" tabindex="-1"></a>            qe <span class="op">=</span> <span class="va">self</span>.quantization_error(X)</span>
<span id="cb164-52"><a href="#cb164-52" aria-hidden="true" tabindex="-1"></a>            te <span class="op">=</span> <span class="va">self</span>.topographic_error(X)</span>
<span id="cb164-53"><a href="#cb164-53" aria-hidden="true" tabindex="-1"></a>            qe_errors.append(qe)</span>
<span id="cb164-54"><a href="#cb164-54" aria-hidden="true" tabindex="-1"></a>            te_errors.append(te)</span>
<span id="cb164-55"><a href="#cb164-55" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb164-56"><a href="#cb164-56" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> verbose:</span>
<span id="cb164-57"><a href="#cb164-57" aria-hidden="true" tabindex="-1"></a>                <span class="bu">print</span>(<span class="ss">f'Epoch: </span><span class="sc">{</span>epoch<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss"> | QE: </span><span class="sc">{</span>qe<span class="sc">:.4f}</span><span class="ss">, TE: </span><span class="sc">{</span>te<span class="sc">:.4f}</span><span class="ss">'</span>)</span>
<span id="cb164-58"><a href="#cb164-58" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb164-59"><a href="#cb164-59" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.weights, qe_errors, te_errors</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Would you like me to: 1. Add the error metrics methods next 2. Add the transform method 3. Explain any part of this implementation in more detail</p>
<p>Which would you prefer?</p>
</div>
</div>
<p><strong>AI Prompt</strong></p>
<p>Ok, add the error metrics methods next</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>AI Response</strong></p>
<p>I’ll add the error metrics methods to our SOM class:</p>
<div class="sourceCode" id="cb165"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SOM:</span>
<span id="cb165-2"><a href="#cb165-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ... (previous methods remain the same)</span></span>
<span id="cb165-3"><a href="#cb165-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb165-4"><a href="#cb165-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> quantization_error(<span class="va">self</span>, X:np.ndarray)<span class="op">-&gt;</span><span class="bu">float</span>:</span>
<span id="cb165-5"><a href="#cb165-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">"Calculate average distance between each input vector and its BMU"</span></span>
<span id="cb165-6"><a href="#cb165-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.array([</span>
<span id="cb165-7"><a href="#cb165-7" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.dist_fn(x, <span class="va">self</span>.weights).<span class="bu">min</span>() </span>
<span id="cb165-8"><a href="#cb165-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> x <span class="kw">in</span> X</span>
<span id="cb165-9"><a href="#cb165-9" aria-hidden="true" tabindex="-1"></a>        ]).mean()</span>
<span id="cb165-10"><a href="#cb165-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb165-11"><a href="#cb165-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> topographic_error(<span class="va">self</span>, X:np.ndarray)<span class="op">-&gt;</span><span class="bu">float</span>:</span>
<span id="cb165-12"><a href="#cb165-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">"Calculate proportion of data vectors where 1st and 2nd BMUs are not adjacent"</span></span>
<span id="cb165-13"><a href="#cb165-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> _check_bmu_adjacency(x):</span>
<span id="cb165-14"><a href="#cb165-14" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Get indices of two best matching units</span></span>
<span id="cb165-15"><a href="#cb165-15" aria-hidden="true" tabindex="-1"></a>            distances <span class="op">=</span> <span class="va">self</span>.dist_fn(x, <span class="va">self</span>.weights)</span>
<span id="cb165-16"><a href="#cb165-16" aria-hidden="true" tabindex="-1"></a>            flat_indices <span class="op">=</span> np.argpartition(distances.flatten(), <span class="dv">2</span>)[:<span class="dv">2</span>]</span>
<span id="cb165-17"><a href="#cb165-17" aria-hidden="true" tabindex="-1"></a>            indices <span class="op">=</span> np.unravel_index(flat_indices, <span class="va">self</span>.grid_sz)</span>
<span id="cb165-18"><a href="#cb165-18" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Check if any coordinate differs by more than 1</span></span>
<span id="cb165-19"><a href="#cb165-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="bu">any</span>(np.<span class="bu">abs</span>(x<span class="op">-</span>y) <span class="op">&gt;</span> <span class="dv">1</span> <span class="cf">for</span> x,y <span class="kw">in</span> indices)</span>
<span id="cb165-20"><a href="#cb165-20" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb165-21"><a href="#cb165-21" aria-hidden="true" tabindex="-1"></a>        n_errors <span class="op">=</span> <span class="bu">sum</span>(_check_bmu_adjacency(x) <span class="cf">for</span> x <span class="kw">in</span> X)</span>
<span id="cb165-22"><a href="#cb165-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">100</span> <span class="op">*</span> n_errors <span class="op">/</span> <span class="bu">len</span>(X)  <span class="co"># Return percentage</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Would you like me to: 1. Add the transform method next 2. Add the U-Matrix visualization 3. Add component planes visualization 4. Something else?</p>
<p>Which would you prefer?</p>
</div>
</div>
<p><strong>AI Prompt</strong></p>
<p>Add the transform method.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>AI Response</strong></p>
<p>I’ll add the transform method to find BMU coordinates for new data points:</p>
<div class="sourceCode" id="cb166"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb166-1"><a href="#cb166-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SOM:</span>
<span id="cb166-2"><a href="#cb166-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ... (previous methods remain the same)</span></span>
<span id="cb166-3"><a href="#cb166-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb166-4"><a href="#cb166-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> transform(<span class="va">self</span>, X:np.ndarray)<span class="op">-&gt;</span>np.ndarray:</span>
<span id="cb166-5"><a href="#cb166-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">"Find Best Matching Unit (BMU) coordinates for each input vector"</span></span>
<span id="cb166-6"><a href="#cb166-6" aria-hidden="true" tabindex="-1"></a>        bmu_coords <span class="op">=</span> np.zeros((<span class="bu">len</span>(X), <span class="dv">2</span>), dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb166-7"><a href="#cb166-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i, x <span class="kw">in</span> <span class="bu">enumerate</span>(X):</span>
<span id="cb166-8"><a href="#cb166-8" aria-hidden="true" tabindex="-1"></a>            bmu_coords[i] <span class="op">=</span> <span class="va">self</span>._find_bmu(x)</span>
<span id="cb166-9"><a href="#cb166-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> bmu_coords</span>
<span id="cb166-10"><a href="#cb166-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb166-11"><a href="#cb166-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> predict(<span class="va">self</span>, X:np.ndarray)<span class="op">-&gt;</span>np.ndarray:</span>
<span id="cb166-12"><a href="#cb166-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">"Alias for transform method to follow sklearn convention"</span></span>
<span id="cb166-13"><a href="#cb166-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.transform(X)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>I added both <code>transform</code> and <code>predict</code> methods to follow scikit-learn conventions. The <code>predict</code> method is just an alias for <code>transform</code>.</p>
<p>Would you like me to: 1. Add the U-Matrix visualization next 2. Add component planes visualization 3. Add any other methods?</p>
<p>Which would you prefer?</p>
</div>
</div>
<p><strong>AI Prompt</strong></p>
<p>Now, implement the U-matrix component.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>AI Response</strong></p>
<p>I’ll add the U-Matrix calculation and visualization methods:</p>
<div class="sourceCode" id="cb167"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb167-1"><a href="#cb167-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SOM:</span>
<span id="cb167-2"><a href="#cb167-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ... (previous methods remain the same)</span></span>
<span id="cb167-3"><a href="#cb167-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb167-4"><a href="#cb167-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _calculate_umatrix(<span class="va">self</span>)<span class="op">-&gt;</span>np.ndarray:</span>
<span id="cb167-5"><a href="#cb167-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">"Calculate U-Matrix values for current weights"</span></span>
<span id="cb167-6"><a href="#cb167-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> _neighbor_distances(pos):</span>
<span id="cb167-7"><a href="#cb167-7" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Offsets for 8 neighbors</span></span>
<span id="cb167-8"><a href="#cb167-8" aria-hidden="true" tabindex="-1"></a>            nbr_offsets <span class="op">=</span> [</span>
<span id="cb167-9"><a href="#cb167-9" aria-hidden="true" tabindex="-1"></a>                (<span class="op">-</span><span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>), (<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>), (<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>),  <span class="co"># top-left, top, top-right</span></span>
<span id="cb167-10"><a href="#cb167-10" aria-hidden="true" tabindex="-1"></a>                (<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>),          (<span class="dv">0</span>,<span class="dv">1</span>),   <span class="co"># left, right</span></span>
<span id="cb167-11"><a href="#cb167-11" aria-hidden="true" tabindex="-1"></a>                (<span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>),  (<span class="dv">1</span>,<span class="dv">0</span>),  (<span class="dv">1</span>,<span class="dv">1</span>)    <span class="co"># bottom-left, bottom, bottom-right</span></span>
<span id="cb167-12"><a href="#cb167-12" aria-hidden="true" tabindex="-1"></a>            ]</span>
<span id="cb167-13"><a href="#cb167-13" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb167-14"><a href="#cb167-14" aria-hidden="true" tabindex="-1"></a>            distances <span class="op">=</span> []</span>
<span id="cb167-15"><a href="#cb167-15" aria-hidden="true" tabindex="-1"></a>            weights <span class="op">=</span> []</span>
<span id="cb167-16"><a href="#cb167-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> dr, dc <span class="kw">in</span> nbr_offsets:</span>
<span id="cb167-17"><a href="#cb167-17" aria-hidden="true" tabindex="-1"></a>                r, c <span class="op">=</span> pos</span>
<span id="cb167-18"><a href="#cb167-18" aria-hidden="true" tabindex="-1"></a>                nbr_r, nbr_c <span class="op">=</span> r<span class="op">+</span>dr, c<span class="op">+</span>dc</span>
<span id="cb167-19"><a href="#cb167-19" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> (nbr_r <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> nbr_r <span class="op">&lt;</span> <span class="va">self</span>.grid_sz[<span class="dv">0</span>] <span class="kw">and</span> </span>
<span id="cb167-20"><a href="#cb167-20" aria-hidden="true" tabindex="-1"></a>                    nbr_c <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> nbr_c <span class="op">&lt;</span> <span class="va">self</span>.grid_sz[<span class="dv">1</span>]):</span>
<span id="cb167-21"><a href="#cb167-21" aria-hidden="true" tabindex="-1"></a>                    w <span class="op">=</span> <span class="dv">1</span><span class="op">/</span>np.sqrt(dr<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> dc<span class="op">**</span><span class="dv">2</span>)  <span class="co"># weight by distance</span></span>
<span id="cb167-22"><a href="#cb167-22" aria-hidden="true" tabindex="-1"></a>                    weights.append(w)</span>
<span id="cb167-23"><a href="#cb167-23" aria-hidden="true" tabindex="-1"></a>                    d <span class="op">=</span> <span class="va">self</span>.dist_fn(<span class="va">self</span>.weights[r,c] <span class="op">-</span> <span class="va">self</span>.weights[nbr_r,nbr_c])</span>
<span id="cb167-24"><a href="#cb167-24" aria-hidden="true" tabindex="-1"></a>                    distances.append(d)</span>
<span id="cb167-25"><a href="#cb167-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> np.average(distances, weights<span class="op">=</span>weights)</span>
<span id="cb167-26"><a href="#cb167-26" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb167-27"><a href="#cb167-27" aria-hidden="true" tabindex="-1"></a>        umatrix <span class="op">=</span> np.zeros(<span class="va">self</span>.grid_sz)</span>
<span id="cb167-28"><a href="#cb167-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i, j <span class="kw">in</span> np.ndindex(<span class="va">self</span>.grid_sz):</span>
<span id="cb167-29"><a href="#cb167-29" aria-hidden="true" tabindex="-1"></a>            umatrix[i,j] <span class="op">=</span> _neighbor_distances((i,j))</span>
<span id="cb167-30"><a href="#cb167-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> umatrix</span>
<span id="cb167-31"><a href="#cb167-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb167-32"><a href="#cb167-32" aria-hidden="true" tabindex="-1"></a>    <span class="at">@property</span></span>
<span id="cb167-33"><a href="#cb167-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> umatrix(<span class="va">self</span>)<span class="op">-&gt;</span>np.ndarray:</span>
<span id="cb167-34"><a href="#cb167-34" aria-hidden="true" tabindex="-1"></a>        <span class="co">"Return the U-Matrix for current weights"</span></span>
<span id="cb167-35"><a href="#cb167-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>._calculate_umatrix()</span>
<span id="cb167-36"><a href="#cb167-36" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb167-37"><a href="#cb167-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> plot_umatrix(<span class="va">self</span>, figsize<span class="op">=</span>(<span class="dv">8</span>,<span class="dv">6</span>), cmap<span class="op">=</span><span class="st">'viridis_r'</span>):</span>
<span id="cb167-38"><a href="#cb167-38" aria-hidden="true" tabindex="-1"></a>        <span class="co">"Plot U-Matrix visualization"</span></span>
<span id="cb167-39"><a href="#cb167-39" aria-hidden="true" tabindex="-1"></a>        <span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb167-40"><a href="#cb167-40" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb167-41"><a href="#cb167-41" aria-hidden="true" tabindex="-1"></a>        plt.figure(figsize<span class="op">=</span>figsize)</span>
<span id="cb167-42"><a href="#cb167-42" aria-hidden="true" tabindex="-1"></a>        plt.imshow(<span class="va">self</span>.umatrix, cmap<span class="op">=</span>cmap, interpolation<span class="op">=</span><span class="st">'nearest'</span>)</span>
<span id="cb167-43"><a href="#cb167-43" aria-hidden="true" tabindex="-1"></a>        plt.colorbar(label<span class="op">=</span><span class="st">'Average distance to neighbors'</span>)</span>
<span id="cb167-44"><a href="#cb167-44" aria-hidden="true" tabindex="-1"></a>        plt.title(<span class="st">'U-Matrix'</span>)</span>
<span id="cb167-45"><a href="#cb167-45" aria-hidden="true" tabindex="-1"></a>        plt.tight_layout()</span>
<span id="cb167-46"><a href="#cb167-46" aria-hidden="true" tabindex="-1"></a>        plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>I’ve included: 1. Internal calculation method <code>_calculate_umatrix</code> 2. Property getter for easy access to U-Matrix 3. Plotting method with customizable parameters</p>
<p>Would you like me to: 1. Add component planes visualization next 2. Add any other visualization methods 3. Explain any part of the U-Matrix implementation in more detail?</p>
<p>Which would you prefer?</p>
</div>
</div>
<section id="v.2-readme.md" class="level3">
<h3 class="anchored">V.2 Readme.md</h3>
<p><strong>AI Prompt</strong></p>
<p>Last, I’d like you to generate a <code>README.md</code> file for a package making this SOM implementation available to a wider audience (let’s name this package Teuvo). I’d like it to mention the design philosophy of “SolveIt” also. Use a how to use section using the MNIST dataset for instance.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>AI Response</strong> I’ll create a README.md for the “Teuvo” package (nice reference to Teuvo Kohonen!). I’ll structure it to be clear, informative, and showcase the implementation philosophy:</p>
<div class="sourceCode" id="cb168"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb168-1"><a href="#cb168-1" aria-hidden="true" tabindex="-1"></a><span class="fu"># Teuvo: A Pythonic Self-Organizing Map Implementation</span></span>
<span id="cb168-2"><a href="#cb168-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-3"><a href="#cb168-3" aria-hidden="true" tabindex="-1"></a>A flexible, well-documented implementation of Self-Organizing Maps (SOMs) following the principles of clarity, step-by-step problem solving, and vectorized operations.</span>
<span id="cb168-4"><a href="#cb168-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-5"><a href="#cb168-5" aria-hidden="true" tabindex="-1"></a><span class="fu">## Design Philosophy</span></span>
<span id="cb168-6"><a href="#cb168-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-7"><a href="#cb168-7" aria-hidden="true" tabindex="-1"></a>This implementation follows the "SolveIt" approach:</span>
<span id="cb168-8"><a href="#cb168-8" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Break complex problems into manageable steps</span>
<span id="cb168-9"><a href="#cb168-9" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Prioritize clarity and understanding over premature optimization</span>
<span id="cb168-10"><a href="#cb168-10" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Document and explain each component thoroughly</span>
<span id="cb168-11"><a href="#cb168-11" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Use vectorized operations for efficiency</span>
<span id="cb168-12"><a href="#cb168-12" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Provide flexible interfaces for customization</span>
<span id="cb168-13"><a href="#cb168-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-14"><a href="#cb168-14" aria-hidden="true" tabindex="-1"></a><span class="fu">## Installation</span></span>
<span id="cb168-15"><a href="#cb168-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-16"><a href="#cb168-16" aria-hidden="true" tabindex="-1"></a><span class="in">```bash</span></span>
<span id="cb168-17"><a href="#cb168-17" aria-hidden="true" tabindex="-1"></a><span class="ex">pip</span> install teuvo</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="quick-start" class="level2">
<h2 class="anchored" data-anchor-id="quick-start">Quick Start</h2>
<div class="sourceCode" id="cb169"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb169-1"><a href="#cb169-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> teuvo <span class="im">import</span> SOM</span>
<span id="cb169-2"><a href="#cb169-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb169-3"><a href="#cb169-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.datasets <span class="im">import</span> load_digits</span>
<span id="cb169-4"><a href="#cb169-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb169-5"><a href="#cb169-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Load and normalize MNIST data</span></span>
<span id="cb169-6"><a href="#cb169-6" aria-hidden="true" tabindex="-1"></a>X, y <span class="op">=</span> load_digits(return_X_y<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb169-7"><a href="#cb169-7" aria-hidden="true" tabindex="-1"></a>X_norm <span class="op">=</span> (X <span class="op">-</span> np.mean(X, axis<span class="op">=-</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">True</span>))<span class="op">/</span>X.<span class="bu">max</span>()</span>
<span id="cb169-8"><a href="#cb169-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb169-9"><a href="#cb169-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Create and train SOM</span></span>
<span id="cb169-10"><a href="#cb169-10" aria-hidden="true" tabindex="-1"></a>som <span class="op">=</span> SOM(grid_sz<span class="op">=</span>(<span class="dv">20</span>,<span class="dv">20</span>), input_dim<span class="op">=</span><span class="dv">64</span>, init<span class="op">=</span><span class="st">'pca'</span>)</span>
<span id="cb169-11"><a href="#cb169-11" aria-hidden="true" tabindex="-1"></a>som.fit(X_norm, n_epochs<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb169-12"><a href="#cb169-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb169-13"><a href="#cb169-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize results</span></span>
<span id="cb169-14"><a href="#cb169-14" aria-hidden="true" tabindex="-1"></a>som.plot_umatrix()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="features" class="level2">
<h2 class="anchored" data-anchor-id="features">Features</h2>
<ul>
<li>Multiple initialization methods:
<ul>
<li>Random initialization</li>
<li>PCA-based initialization (for faster convergence)</li>
</ul></li>
<li>Flexible training options:
<ul>
<li>Customizable learning rate schedules</li>
<li>Adjustable neighborhood functions</li>
</ul></li>
<li>Comprehensive quality metrics:
<ul>
<li>Quantization Error</li>
<li>Topographic Error</li>
</ul></li>
<li>Rich visualization tools:
<ul>
<li>U-Matrix visualization</li>
<li>Component planes (coming soon)</li>
</ul></li>
</ul>
</section>
<section id="detailed-example-mnist-digit-classification" class="level2">
<h2 class="anchored" data-anchor-id="detailed-example-mnist-digit-classification">Detailed Example: MNIST Digit Classification</h2>
<div class="sourceCode" id="cb170"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb170-1"><a href="#cb170-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> teuvo <span class="im">import</span> SOM</span>
<span id="cb170-2"><a href="#cb170-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> teuvo.schedulers <span class="im">import</span> Scheduler</span>
<span id="cb170-3"><a href="#cb170-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb170-4"><a href="#cb170-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.datasets <span class="im">import</span> load_digits</span>
<span id="cb170-5"><a href="#cb170-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb170-6"><a href="#cb170-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb170-7"><a href="#cb170-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Load and preprocess data</span></span>
<span id="cb170-8"><a href="#cb170-8" aria-hidden="true" tabindex="-1"></a>X, y <span class="op">=</span> load_digits(return_X_y<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb170-9"><a href="#cb170-9" aria-hidden="true" tabindex="-1"></a>X_norm <span class="op">=</span> (X <span class="op">-</span> np.mean(X, axis<span class="op">=-</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">True</span>))<span class="op">/</span>X.<span class="bu">max</span>()</span>
<span id="cb170-10"><a href="#cb170-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb170-11"><a href="#cb170-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize SOM</span></span>
<span id="cb170-12"><a href="#cb170-12" aria-hidden="true" tabindex="-1"></a>som <span class="op">=</span> SOM(</span>
<span id="cb170-13"><a href="#cb170-13" aria-hidden="true" tabindex="-1"></a>    grid_sz<span class="op">=</span>(<span class="dv">20</span>,<span class="dv">20</span>),</span>
<span id="cb170-14"><a href="#cb170-14" aria-hidden="true" tabindex="-1"></a>    input_dim<span class="op">=</span><span class="dv">64</span>,</span>
<span id="cb170-15"><a href="#cb170-15" aria-hidden="true" tabindex="-1"></a>    init<span class="op">=</span><span class="st">'pca'</span>  <span class="co"># Use PCA initialization</span></span>
<span id="cb170-16"><a href="#cb170-16" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb170-17"><a href="#cb170-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb170-18"><a href="#cb170-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Create custom schedulers</span></span>
<span id="cb170-19"><a href="#cb170-19" aria-hidden="true" tabindex="-1"></a>lr_scheduler <span class="op">=</span> Scheduler(start_val<span class="op">=</span><span class="fl">1.0</span>, end_val<span class="op">=</span><span class="fl">0.01</span>, </span>
<span id="cb170-20"><a href="#cb170-20" aria-hidden="true" tabindex="-1"></a>                       step_size<span class="op">=</span><span class="dv">200</span>, n_samples<span class="op">=</span><span class="bu">len</span>(X), n_epochs<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb170-21"><a href="#cb170-21" aria-hidden="true" tabindex="-1"></a>sigma_scheduler <span class="op">=</span> Scheduler(start_val<span class="op">=</span><span class="fl">10.0</span>, end_val<span class="op">=</span><span class="fl">1.0</span>, </span>
<span id="cb170-22"><a href="#cb170-22" aria-hidden="true" tabindex="-1"></a>                          step_size<span class="op">=</span><span class="dv">200</span>, n_samples<span class="op">=</span><span class="bu">len</span>(X), n_epochs<span class="op">=</span><span class="dv">20</span>)</span>
<span id="cb170-23"><a href="#cb170-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb170-24"><a href="#cb170-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Train</span></span>
<span id="cb170-25"><a href="#cb170-25" aria-hidden="true" tabindex="-1"></a>weights, qe_errors, te_errors <span class="op">=</span> som.fit(</span>
<span id="cb170-26"><a href="#cb170-26" aria-hidden="true" tabindex="-1"></a>    X_norm,</span>
<span id="cb170-27"><a href="#cb170-27" aria-hidden="true" tabindex="-1"></a>    n_epochs<span class="op">=</span><span class="dv">20</span>,</span>
<span id="cb170-28"><a href="#cb170-28" aria-hidden="true" tabindex="-1"></a>    lr_scheduler<span class="op">=</span>lr_scheduler,</span>
<span id="cb170-29"><a href="#cb170-29" aria-hidden="true" tabindex="-1"></a>    sigma_scheduler<span class="op">=</span>sigma_scheduler</span>
<span id="cb170-30"><a href="#cb170-30" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb170-31"><a href="#cb170-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb170-32"><a href="#cb170-32" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize results</span></span>
<span id="cb170-33"><a href="#cb170-33" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">12</span>,<span class="dv">4</span>))</span>
<span id="cb170-34"><a href="#cb170-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb170-35"><a href="#cb170-35" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">121</span>)</span>
<span id="cb170-36"><a href="#cb170-36" aria-hidden="true" tabindex="-1"></a>plt.plot(qe_errors)</span>
<span id="cb170-37"><a href="#cb170-37" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Quantization Error'</span>)</span>
<span id="cb170-38"><a href="#cb170-38" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Epoch'</span>)</span>
<span id="cb170-39"><a href="#cb170-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb170-40"><a href="#cb170-40" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">122</span>)</span>
<span id="cb170-41"><a href="#cb170-41" aria-hidden="true" tabindex="-1"></a>som.plot_umatrix()</span>
<span id="cb170-42"><a href="#cb170-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb170-43"><a href="#cb170-43" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb170-44"><a href="#cb170-44" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="contributing" class="level2">
<h2 class="anchored" data-anchor-id="contributing">Contributing</h2>
<p>We welcome contributions! Please see our contributing guidelines for details.</p>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
<ul>
<li>Kohonen, T. (1982). Self-organized formation of topologically correct feature maps</li>
<li>Kohonen, T. (2013). Essentials of the self-organizing map</li>
<li>Polya, G. (1945). How to Solve It</li>
</ul>
</section>
<section id="license" class="level2">
<h2 class="anchored" data-anchor-id="license">License</h2>
<p>MIT</p>
</section>
<section id="acknowledgments" class="level2">
<h2 class="anchored" data-anchor-id="acknowledgments">Acknowledgments</h2>
<p>Named in honor of Teuvo Kohonen, who introduced the Self-Organizing Map algorithm.</p>
<pre><code>
Would you like me to:
1. Add more examples
2. Expand any section
3. Add installation or dependency details
4. Add anything else?

:::

**AI Prompt**

Last request! Can you generate a TOC for the whole notebook that I will prepend for easier navigation?

**AI Response**

Here's a Table of Contents for your notebook:

```markdown
# Self-Organizing Map Implementation

## Table of Contents

I. CORE SOM COMPONENTS
   - I.1 Weight Grid Initialization
   - I.2 Distance Metrics
   - I.3 BMU (Best Matching Unit)
   - I.4 Neighborhood Function
   - I.5 Weight Update Rule

II. EXTENDED TRAINING COMPONENTS
   - II.1 A 2D Toy Dataset
   - II.2 U-Matrix
   - II.3 Naive Training Loop
   - II.4 Quantization Error (QE)
   - II.5 Topographic Error (TE)
   - II.6 LR and σ Schedulers
   - II.7 Advanced Training Loop with Schedulers
   - II.8 Revised Plan

III. WEIGHTS INITIALIZATION METHODS
   - III.1 Random Initialization
   - III.2 PCA Initialization

IV. ADDITIONAL VISUALIZATIONS

V. REFACTORING
   - V.1 Class Implementation
   - V.2 README.md

Each section follows the step-by-step development process, from basic components to the final package implementation.</code></pre>
<p>Would you like me to: 1. Add more detail to any section 2. Reorganize any part 3. Add subsections I might have missed?</p>


</section>
</div>
</div>
</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/franckalbinet\.github\.io\/teuvo");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




<footer class="footer"><div class="nav-footer"><div class="nav-footer-center"><div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/franckalbinet/teuvo/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></div></div></footer></body></html>